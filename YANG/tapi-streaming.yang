module tapi-streaming {
    yang-version "1.1";
    namespace "urn:onf:otcc:yang:tapi-streaming";
    prefix tapi-streaming;
    import tapi-common {
        prefix tapi-common;
    }
    organization "ONF OTCC (Open Transport Configuration & Control) Project";
    contact "
         Project Web: <https://wiki.opennetworking.org/display/OTCC/TAPI>
         Project List: <mailto:transport-api@opennetworking.org>
         Editor: Karthik Sethuraman <mailto:karthik.sethuraman@necam.com>
         Andrea Mazzini <mailto:andrea.mazzini@nokia.com>
         Arturo Mayoral <mailto:arturo.mayoral@telefonica.com>
         Nigel Davis <mailto:ndavis@ciena.com>
         Ramon Casellas <mailto:ramon.casellas@cttc.es>";
    description "
        This module contains TAPI Streaming Model definitions.
        Source: TapiStreaming.uml
        - The TAPI YANG models included in this TAPI release are a *normative* part of the TAPI SDK.
        - The YANG specifications have been generated from the corresponding UML model using the [ONF EAGLE UML2YANG mapping tool]

<https://github.com/OpenNetworkingFoundation/EagleUmlYang>
        and further edited manually to comply with the [ONF IISOMI UML2YANG mapping guidelines]
        <https://wiki.opennetworking.org/display/OIMT/UML+-+YANG+Guidelines>
        - Status of YANG model artifacts can be determined by referring to the corresponding UML artifacts.
        As described in the UML models, some artifacts are considered *experimental*, and thus the corresponding YANG artifacts.
        - The ONF TAPI release process does not guarantee backward compatibility of YANG models across major versions of TAPI releases.
        The YANG model backward compatibility criteria are outlined in section 11 of <https://tools.ietf.org/html/rfc7950>.
        YANG models included in this release may not be backward compatible with previous TAPI releases.
        Copyright (c) 2021 Open Networking Foundation (ONF). All rights reserved.
        License: This module is distributed under the Apache License 2.0.";
    revision 2021-09-24 {
        description "ONF Transport API version 2.3.1.
                   Changes included in this TAPI release (v2.3.1) are listed in
                   <https://wiki.opennetworking.org/display/OTCC/TAPI+Roadmap+2021>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.3.1/UML>";
    }
    revision 2021-08-04 {
        description "ONF Transport API version 2.3.
                   Changes included in this TAPI release (v2.3) are listed in
                   <https://wiki.opennetworking.org/display/OTCC/TAPI+Roadmap+2021>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.3/UML>";
    }
    revision 2021-05-24 {
        description "ONF Transport API version 2.3 RC1.
                   Changes included in this TAPI release (v2.3) are listed in
                   <https://wiki.opennetworking.org/display/OTCC/TAPI+Roadmap+2021>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.3/UML>";
    }
    revision 2020-06-16 {
        description "ONF Transport API version 2.1.3.
                   - Comment typos corrected.
                   - One attribute changed (sourcePrecesion/source-precesion --> sourcePrecision/source-precision).
                   Changes included in this TAPI release (v2.1.3) are listed in

<https://github.com/OpenNetworkingFoundation/TAPI/blob/develop_v2_1/CHANGE_LOG/change-log.2.1.3.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.1.3/UML>";
    }
    revision 2019-07-16 {
        description "ONF Transport API version 2.1.2.
                   Changes included in this TAPI release (v2.1.2) are listed in
                   <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop_v2_1/CHANGE_LOG/change-log.2.1.2.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.1.2/UML>";
    }
    revision 2019-03-31 {
        description "ONF Transport API version 2.2-RC1.
                   Changes included in this TAPI release (v2.2) are listed in
                  <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.2.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.2.0/UML>";
    }
    revision 2018-12-10 {
        description "ONF Transport API version 2.1.1.
                   Changes included in this TAPI release (v2.1.1) are listed in
                  <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.1.1.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.1.1/UML>";
    }
    revision 2018-10-16 {
        description "ONF Transport API version 2.1.0.
                   Changes included in this TAPI release (v2.1.0) are listed in
                  <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.1.0.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.1.0/UML>";
    }
    revision 2018-03-07 {
        description "ONF Transport API version 2.0.2
        This YANG module has been generated from the TAPI UML Model using the IISOMI-Eagle xmi2yang mapping tool.
        Changes in this revision: <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.0.2.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 6020, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.0.2/UML>";
    }
    revision 2018-02-16 {
        description "ONF Transport API version 2.0.1
        This YANG module has been generated from the TAPI UML Model using the IISOMI-Eagle xmi2yang mapping tool.
        Changes in this revision: <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.0.1.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 6020, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.0.1/UML>";
    }
    revision 2018-01-02 {
        description "ONF Transport API version 2.0.0
        This YANG module has been generated from the TAPI UML Model using the IISOMI-Eagle xmi2yang mapping tool.
        Changes in this revision: <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.0.0.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 6020, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.0.0/UML>";
    }
    feature tapi-streaming {
        description "Support for streaming of the information in the specific TAPI context, in terms of stream-records. Through augmentation of context with stream-context, allows the client to determine what specific stream connections are supported and which are currently available to connect to. Offers the ability to identify and use various log strategies and stream connection protocols.";
    }
    feature tapi-streaming-admin {
        description "Support for monitoring of active connections to available streams. Through augmentation of context with stream-admin-context, allows the admin client to get details from monitors of active connections to provide a view of whether the client of the monitored stream is having difficult absorbing the stream. Will usually be used in a tapi context for a stream admin client. Will usually be used together with the tapi-streaming feature so that the stream monitors from one stream could be provided through another stream .";
    }
    augment "/tapi-common:context/tapi-streaming:stream-context/tapi-streaming:supported-stream-type" {
        if-feature tapi-streaming;
        container compacted-log-details {
            uses compacted-log-details;
            description "none";
        }
        description "none";
    }
    augment "/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body/tapi-streaming:condition-detector" {
        if-feature tapi-streaming;
        container alarm-condition-detector-detail {
            uses alarm-condition-detector-detail;
            description "none";
        }
        description "none";
    }
    augment "/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
        when 'derived-from-or-self(tapi-streaming:record-content, "CONDITION_DETECTOR")';
        if-feature tapi-streaming;
        container condition-detector {
            uses condition-detector;
            description "none";
        }
        description "none";
    }
    augment "/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
        when 'derived-from-or-self(tapi-streaming:record-content, "ANY_CLASS")';
        if-feature tapi-streaming;
        container any-class {
            uses any-class;
            description "none";
        }
        description "none";
    }
    augment "/tapi-common:context" {
        if-feature tapi-streaming-admin;
        container stream-admin-context {
            uses stream-admin-context;
            description "Augments the base TAPI Context with StreamAdminContext model.";
        }
        description "Augments the base TAPI Context with StreamAdminContext model.";
    }
    augment "/tapi-common:context" {
        if-feature tapi-streaming;
        container stream-context {
            uses stream-context;
            description "Augments the base TAPI Context with StreamContext model.";
        }
        description "Augments the base TAPI Context with StreamContext model.";
    }
    augment "/tapi-common:context/tapi-streaming:stream-context/tapi-streaming:supported-stream-type" {
        if-feature tapi-streaming;
        container connection-protocol-details {
            uses connection-protocol-details;
            description "none";
        }
        description "none";
    }
    augment "/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
        when 'derived-from-or-self(tapi-streaming:record-content, "STREAM_MONITOR")';
        if-feature tapi-streaming-admin;
        container stream-monitor {
            uses stream-monitor;
            description "none";
        }
        description "none";
    }
    augment "/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
        when 'derived-from-or-self(tapi-streaming:record-content, "SUPPORTED_STREAM_TYPE")';
        if-feature tapi-streaming;
        container supported-stream-type {
            uses supported-stream-type;
            description "none";
        }
        description "none";
    }
    augment "/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
        when 'derived-from-or-self(tapi-streaming:record-content, "AVAILABLE_STREAM_TYPE")';
        if-feature tapi-streaming;
        container available-stream {
            uses available-stream;
            description "none";
        }
        description "none";
    }
    augment "/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
        when 'derived-from-or-self(tapi-streaming:record-content, "OBJECT_TYPE_SERVICE_INTERFACE_POINT")';
        if-feature tapi-streaming;
        container service-interface-point {
            uses tapi-common:service-interface-point;
            description "none";
        }
        description "none";
    }
   /**************************
    * definitions of references
    **************************/
    grouping available-stream-ref {
        leaf available-stream-uuid{
            type leafref {
                path '/tapi-common:context/tapi-streaming:stream-context/tapi-streaming:available-stream/tapi-streaming:uuid';
            }
            description "none";
        }
        description "none";
    }
    grouping supported-stream-type-ref {
        leaf supported-stream-type-uuid {
            type leafref {
                path '/tapi-common:context/tapi-streaming:stream-context/tapi-streaming:supported-stream-type/tapi-streaming:uuid';
            }
            description "none";
        }
        description "none";
    }
    /**************************
    * package type-definitions
    **************************/ 
    identity ALARM_DETECTOR_STATE {
        description "none";
    }
    identity ALARM_DETECTOR_STATE_ACTIVE {
        base ALARM_DETECTOR_STATE;
        description "The detector is indicating the operation of the monitored entity is not within acceptable bounds with respect to the specific condition measured.
            If INTERMITTENT is supported there may be a requirement for persisted unacceptable operation after a problem occurs before ACTIVE is declared. An alternative may be to declare INTERMITTENT.
            Where INTERMITTENT is supported, ACTIVE indicates the stable presence of a problem.";
    }
    identity ALARM_DETECTOR_STATE_INTERMITTENT {
        base ALARM_DETECTOR_STATE;
        description "The detector is indicating the operation of the monitored entity is intermittently not within acceptable bounds with respect to the specific condition measured.
            INTERMITTENT support is optional. Where it is supported there may be a requirement for persisted unacceptable operation after a problem occurs before ACTIVE or INTERMITTENT is declared.";
    }
    identity ALARM_DETECTOR_STATE_CLEAR {
        base ALARM_DETECTOR_STATE;
        description "The detector is indicating the operation of the monitored entity is within acceptable bounds with respect to the specific condition measured.
            There may be a requirement for persisted acceptable operation after a problem before clear is declared etc.
            For a Compacted Log solution a CLEAR alarm will be considered as a DELETE ChangeType in the RecordBody.
            Hence a CLEAR will also cause a Tombstone record in a Compacted Log solution.";
    }
    identity LOG_RECORD_STRATEGY {
        description "none";
    }
    identity LOG_RECORD_STRATEGY_WHOLE_ENTITY_ON_CHANGE {
        base LOG_RECORD_STRATEGY;
        description "A record provides a snapshot of a whole entity and a snapshot is taken on each change.
            The record includes all properties and values whether they have changed or not.";
    }
    identity LOG_RECORD_STRATEGY_CHANGE_ONLY {
        base LOG_RECORD_STRATEGY;
        description "Each record only provides a view of the changes that have occurred (on a per entity change basis).
            E.g., the log only includes the attribute that has changed and not other attributes that have not changed.";
    }
    identity LOG_RECORD_STRATEGY_WHOLE_ENTITY_PERIODIC {
        base LOG_RECORD_STRATEGY;
        description "A snapshot of an entity is recorded periodically regardless of whether there has been change or not.";
    }
    identity LOG_STORAGE_STRATEGY {
        description "none";
    }
    identity LOG_STORAGE_STRATEGY_COMPACTED {
        base LOG_STORAGE_STRATEGY;
        description "The log uses some mechanism to remove noisy detail whilst enabling the client to achieve eventual consistency (alignment) with current state.";
    }
    identity LOG_STORAGE_STRATEGY_TRUNCATED {
        base LOG_STORAGE_STRATEGY;
        description "The log only maintains recent records and disposes of old records. 
            This log does not alone enable the client to achieve alignment with current state.";
    }
    identity LOG_STORAGE_STRATEGY_FULL_HISTORY {
        base LOG_STORAGE_STRATEGY;
        description "Maintains a history from system initiation with no missing records. 
            Provides initial state at the beginning of the history";
    }
    identity LOG_STORAGE_STRATEGY_FULL_HISTORY_WITH_PERIODIC_BASELINE {
        base LOG_STORAGE_STRATEGY;
        description "Provides a history with initial state and periodic/occasional statements of current state at a particular point in time.";
    }
    identity STREAM_STATE {
        description "none";
    }
    identity STREAM_STATE_ALIGNING {
        base STREAM_STATE;
        description "The log that underpins the stream is aligning with other backend services and hence may not be providing full service.
            If events are provided, they will be completely valid.";
    }
    identity STREAM_STATE_ACTIVE {
        base STREAM_STATE;
        description "The stream is operating such that if a client connects records will be provided as per back pressure etc.";
    }
    identity STREAM_STATE_PAUSED {
        base STREAM_STATE;
        description "Although the stream is available it has been paused by the administrator such that the records are being appended to the log but a new client will not receive any events whilst the stream is paused.";
    }
    identity STREAM_STATE_TERMINATED {
        base STREAM_STATE;
        description "The stream is essentially no longer available. It will be removed from the AvailableStreams list shortly.";
    }
    identity RECORD_TYPE {
        description "none";
    }
    identity RECORD_TYPE_CREATE_UPDATE {
        base RECORD_TYPE;
        description "The record includes a create or update.
            Where there is an update in a non-compacted log the information with be sparse (e.g., a single attribute) and about an entity that is already known.";
    }
    identity RECORD_TYPE_DELETE {
        base RECORD_TYPE;
        description "The record is about a delete.
            The record may have a LogRecordHeader and a LogRecordBody but no augmented content.
            The entityKey should be sufficient to identify the entity to be deleted.
            Under certain circumstances there may be class content in the LogRecordBody.";
    }
    identity RECORD_TYPE_TOMBSTONE {
        base RECORD_TYPE;
        description "Used in a Compacted log to remove old records and truncate deletion history.
            Is only a LogRecordHeader with no LogRecordBody.";
    }
    identity SOURCE_PRECISION {
        description "none";
    }
    identity SOURCE_PRECISION_UNKNOWN {
        base SOURCE_PRECISION;
        description "The state of the clock at the event source is not known.
            The view of time of day at the source is suspect.";
    }
    identity SOURCE_PRECISION_FREE_RUNNING {
        base SOURCE_PRECISION;
        description "The clock at the event source is free-running.
            The view of time of day at the source may be significantly different from that at other sources.";
    }
    identity SOURCE_PRECISION_SYNCHRONIZED {
        base SOURCE_PRECISION;
        description "The clock at the event source is appropriately synchronized to the timing master.
            The view of time of day at the source should be essentially the same as that at other time-synchronized sources.
            ";
    }
    identity SPREAD {
        description "none";
    }
    identity SPREAD_AT {
        base SPREAD;
        description "The event occurred at a particular time.";
    }
    identity SPREAD_BEFORE {
        base SPREAD;
        description "The event occurred before a particular time.";
    }
    identity SPREAD_AFTER {
        base SPREAD;
        description "The event occurred after a particular time.";
    }
    identity SPREAD_BETWEEN {
        base SPREAD;
        description "The event occurred between two stated times.";
    }
    identity CONDITION_DETECTOR_TYPE {
        description "none";
    }
    identity CONDITION_DETECTOR_TYPE_ALARM_DETECTOR {
        base CONDITION_DETECTOR_TYPE;
        description "A type of detector used for reporting problems.
            The underlying raw detector is two state from the perspective of the monitored condition. 
            The detector is asymmetric in nature. 
            One state indicates that there is a problem and the other state indicates that there is no problem.";
    }
    identity CONDITION_DETECTOR_TYPE_EVENT_DETECTOR {
        base CONDITION_DETECTOR_TYPE;
        description "A type of detector used for reporting events.";
    }
    identity STREAMING_OBJECT_TYPE {
        base tapi-common:OBJECT_TYPE;
        description "none";
    }
    identity STREAMING_OBJECT_TYPE_AVAILABLE_STREAM {
        base STREAMING_OBJECT_TYPE;
        description "none";
    }
    identity STREAMING_OBJECT_TYPE_STREAM_MONITOR {
        base STREAMING_OBJECT_TYPE;
        description "none";
    }
    identity STREAMING_OBJECT_TYPE_SUPPORTED_STREAM_TYPE {
        base STREAMING_OBJECT_TYPE;
        description "none";
    }
    identity STREAMING_OBJECT_TYPE_CONDITION_DETECTOR {
        base STREAMING_OBJECT_TYPE;
        description "none";
    }
    identity STREAMING_OBJECT_TYPE_ANY_CLASS {
        base STREAMING_OBJECT_TYPE;
        description "none";
    }
    typedef alarm-detector-state {
        type identityref {
            base ALARM_DETECTOR_STATE;
        }
        description "The state of the processed Boolean alarm detector.
            The source applies some analysis to the raw detector to determine the state.
            The processing by the source my vary.";
    }
    grouping legacy-properties {
        leaf perceived-severity {
            type perceived-severity;
            description "A device will provide an indication of importance for each alarm. 
                This property indicates the importance.
                In some cases, the severity may change through the life of an active alarm.";
        }
        leaf service-affect {
            type service-affect;
            description "Some devices will indicate, from its very narrow viewpoint, whether service has been impacted or not.
                This property carries this detail.";
        }
        leaf is-acknowledged {
            type boolean;
            description "Devices offer a capability to acknowledge alarms (to stop the bells ringing).
                Often an EMS will offer a similar capability.
                This property reflects the current acknowledge state.";
        }
        leaf-list additional-alarm-info {
            type string;
            description "Often, alarms raised by devices have additional information. 
                This property can be used to convey this.";
        }
        description "At this point in the evolution of control solutions LegacyProperties are probably mandatory, however, it is anticipated that as control solutions advance the LegacyProperties will become irrelevant.";
    }
    typedef log-record-strategy {
        type identityref {
            base LOG_RECORD_STRATEGY;
        }
        description "Defines the different approaches for logging information about an event covering the log trigger and the log content.";
    }
    typedef log-storage-strategy {
        type identityref {
            base LOG_STORAGE_STRATEGY;
        }
        description "Defines the storage (record retention) approach.";
    }
    typedef stream-state {
        type identityref {
            base STREAM_STATE;
        }
        description "The state of the available stream.";
    }
    grouping approx-date-and-time {
        leaf primary-time-stamp {
            type tapi-common:date-and-time;
            config false;
            description "Time of the event at the origin where known precisely.
                Where the event is known to be before particular time, this field records that time.
                Where the event is known to be after a particular time, this field records that time (this is an unusual case where there is no proposed before time).
                Where the event is known to have occurred in a time window, this field records the end time (the time before which the event must have occurred).";
        }
        leaf start-time-stamp {
            type tapi-common:date-and-time;
            config false;
            description "The time after which the event is known to have occurred when the event is known to have occurred between two times.
                The primaryTimeStamp provides the end time.";
        }
        leaf spread {
            type spread;
            config false;
            description "Indicates the knowledge of the time of occurrence of the event.";
        }
        leaf source-precision {
            type source-precision;
            config false;
            description "Indicates how well the source time is synchronized with network time.";
        }
        description "Allows for recording of an aspect of imprecise time.";
    }
    typedef record-type {
        type identityref {
            base RECORD_TYPE;
        }
        description "The type of the record.
            Used to understand what log content will be present and how to interpret it.
            For some record types there is special encoding.
            A ACTIVE alarm and an INTERMITTENT alarm are CREATE_UPDATE.
            A CLEAR alarm is DELETE with an adjacent TOMBSTONE record.";
    }
    typedef source-precision {
        type identityref {
            base SOURCE_PRECISION;
        }
        description "Alternative statements about timing precision at the event source.";
    }
    typedef spread {
        type identityref {
            base SPREAD;
        }
        description "The alternative time of occurrence statements.";
    }
    typedef condition-detector-type {
        type identityref {
            base CONDITION_DETECTOR_TYPE;
        }
        description "The type of condition detector.
            The type relates to the characteristics of the detection and reporting strategies.
            This drives the conditional augment.";
    }
    typedef event-source {
        type enumeration {
            enum RESOURCE_OPERATION {
                description "The event is from the operation of the network resources.
                    The event source has a relatively fast time characteristic.";
            }
            enum MANAGEMENT_OPERATION {
                description "Event is from a Management operation (slow control).
                    The event source has a relatively slow time characteristic.";
            }
            enum UNKNOWN {
                description "The origin of the event is not known.";
            }
        }
        description "Source of the event.
            Use to give some idea of the time characteristics of the event source.";
    }
    typedef perceived-severity {
        type enumeration {
            enum CRITICAL {
                description "The highest severity of ACTIVE/INTERMITTENT alarm.";
            }
            enum MAJOR {
                description "The middle severity of ACTIVE/INTERMITTENT alarm.";
            }
            enum MINOR {
                description "The lowest severity of ACTIVE/INTERMITTENT alarm.";
            }
            enum WARNING {
                description "An extremely low importance ACTIVE/INTERMITTENT alarm (lower than MINOR).";
            }
            enum CLEARED {
                description "The severity of a CLEAR where no other severity information is available.";
            }
        }
        description "The values for importance of an ACTIVE, INTERMITTENT or CLEAR alarm.";
    }
    typedef service-affect {
        type enumeration {
            enum SERVICE_AFFECTING {
                description "The condition is believed to impact service.";
            }
            enum NOT_SERVICE_AFFECTING {
                description "The condition is believed to not impact service.";
            }
            enum UNKNOWN {
                description "The service impact of the condition is not known.";
            }
        }
        description "Indicates whether the device considers the condition to be impacting service.
            Note that the detected condition along with knowledge of the topology and protection provide a more suitable approach.";
    }
    typedef streaming-object-type {
        type identityref {
            base STREAMING_OBJECT_TYPE;
        }
        description "The list of TAPI Streaming Object types/classes.";
    }

    /**************************
    * package object-classes
    **************************/ 
    grouping compacted-log-details {
        leaf tombstone-retention {
            type string;
            config false;
            description "Time in minutes.
                The time period for which a Tombstone record will be held in the log from when it was logged. 
                This provides an adjustment to the essential Compaction strategy such that after the tombstoneRetention period there will be no records about a particular thing that existed but no longer exists.
                Tombstone retention overrides recordRetention for Tombstones.
                Key word 'FOREVER' means that Tombstone records will never be removed from the log.
                Can be adjusted by an administrator (via a separate view) through the life of the stream.";
        }
        leaf compaction-delay {
            type string;
            config false;
            description "Time in minutes. 
                The delay between logging the record and making the record available for compaction.
                This provides an adjustment to the essential Compaction strategy such that there may be several distinct records for the same thing in the where those records are not older than the Compaction Delay.
                Can be adjusted by an administrator (via a separate view) through the life of the stream.";
        }
        description "Details relevant for a CompactedLog.
            The essential Compacted Log strategy is to remove historic records about a particular thing such that only the latest record about each thing exists in the log.
            The essential strategy is refined by the parameters of this structure.";
    }
    grouping alarm-condition-detector-detail {
        leaf alarm-detector-state {
            type alarm-detector-state;
            config false;
            description "The state of the detector.
                The detector state accounts for the time characteristics of the detected condition.";
        }
        container legacy-properties {
            config false;
            uses legacy-properties;
            description "Alarm systems of the 20th century were based primarily on local lamps (initially filament bulbs) and bells.
                Lamps can only be on or off, and bells sounding or not sounding, so alarms were Boolean in nature.
                Where a detector was essentially multi-state it was converted into multiple Boolean statements.
                The management of the equipments was essentially human only and local only (there were rarely remote systems).
                The device with the problem was the only possible indicator of importance and it had only three distinct bulbs to illuminate (filament bulbs tend to fail requiring costly replacement).
                The devices were relatively simple in function and analysis of the detectors was crude.
                There was only the device to indicate severity
                The device also could provide the best view as to whether a service was impacted, although clearly it had almost no knowledge.
                In a modern solution with well-connected remote systems that increasingly analyze problems and where there is increasingly 'lights out' building operation, the device's guess at severity etc. is irrelevant.
                In addition, with sophisticated resilience mechanisms, the device cannot make any relevant statement on whether the customer service has been impacted.
                Likewise, in a world where there were no remote systems and local management was the only practice, alarms had to be locally 'acknowledged'. 
                Where there are remote systems, per alarm acknowledge is burdensome.
                However, many solutions and operational practices continue to use the historic schemes.
                On that basis, the schemes are supported but relegated to optional.";
        }
        description "A record of the state of a detector where that detector has two underling states that are of asymmetric importance.";
    }
    grouping condition-detector {
        leaf condition-native-name {
            type string;
            config false;
            description "The name used for the Condition by the source of the information.";
        }
        leaf measured-entity-uuid {
            type tapi-common:uuid;
            config false;
            description "The uuid of the TAPI entity that represents the entity measured at source.
                If the TAPI entity cannot be identified as it cannot be mapped, then this property can be omitted.
                If the TAPI entity is a local class, then this is the UUID of the GlobalClass parent of the entity of which this is part.";
        }
        leaf measured-entity-native-id {
            type string;
            config false;
            description "The identifier (invariant over the life) of the instance of the measured entity at the source.";
        }
        leaf condition-normalized-name {
            type string;
            config false;
            description "It is often the case that there is a Condition Name that is commonly used or even standardized that has not been used by the source of the condition. 
                If this is the case, then that common/standard name is provided in via this property.";
        }
        leaf measured-entity-class {
            type tapi-common:object-type;
            config false;
            description "The TAPI class of the measured entity. 
                If the class cannot be identified as it cannot be mapped, then this property can be omitted.";
        }
        leaf detector-uuid {
            type tapi-common:uuid;
            config false;
            description "The uuid of the TAPI entity that represents the detector.
                If the TAPI entity cannot be identified as it cannot be mapped, then this property can be omitted.
                Where the detector is not modelled independently, but instead is a part of the measured entity such that it is identified by a 'local id' built from the UUID of the measured entity and the condition name, then this property may be omitted.";
        }
        leaf detector-native-id {
            type string;
            config false;
            description "The identifier (invariant over the life) of the instance of the detector at the source (e.g. a device).
                The string reported in this field must include the:
                - device identifier
                - one or more resource identifiers including that of the measured entity
                It need not include the condition name.
                ";
        }
        leaf condition-detector-type {
            type condition-detector-type;
            config false;
            description "Identifies the type of detector.
                This drives the conditional augmentation. 
                Some types of detector may not need specific augmentation.
                ";
        }
        leaf-list measured-entity-local-id {
            type string;
            config false;
            description "Where the measured entity is a local class and hence does not have a UUID the local ID is provided in conjunction with the parents ID. 
                The parent may also be a local class in which case its ID is a a local ID along with its parent ID.
                There will be a parent which is a global class which then supplies a UUID.
                The ID of the entity that is being measured is the combination of the UUID and the ordered list of local IDs.
                The local ID may not be provided where:
                - the report about a global class
                - the report is relying on the detectorNativeId.";
        }
        description "ConditionDetector represents any monitoring component that assesses properties of something and determines from those properties what conditions are associated with the thing.
            For example, a thing might be 'too hot' or might be 'unreliable'.
            The monitor may a multi-state output. 
            The ConditionDetector lifecycle depends upon the lifecycle of the thing it is monitoring (this is a general OAM model consideration).
            The entityKey in the AppendLogRecordHeader for a ConditionDetector record is the nativeDetector Id which may be derived from other ids (most robustly, nativeOwningEntityName (to which the detector is associated) + natveConditionName).";
    }
    grouping any-class {
        description "In the final version all classes that can stream will be explicitly associated with the AppendLogRecordBody.";
    }
    grouping stream-admin-context {
        list stream-monitor {
            key 'uuid';
            config false;
            uses stream-monitor;
            description "The list of available stream monitors.";
        }
        uses tapi-common:global-class;
        description "Context providing access to stream administration functionality.";
    }
    grouping stream-monitor {
        leaf id-of-last-record-read-from-log {
            type string;
            config false;
            description "The id/key of the last record read from the log by the client stream.
                The analysis of this value needs to account for stream buffering in the comms layer.";
        }
        leaf id-of-last-record-written-to-log {
            type string;
            config false;
            description "The id/key of the last record written to the log. 
                This is the same value for all clients of the stream.";
        }
        container available-stream {
            uses available-stream-ref;
            config false;
            description "none";
        }
        leaf client-id {
            type string;
            config false;
            description "The id of the connected client.";
        }
        leaf last-updated {
            type tapi-common:date-and-time;
            config false;
            description "The date/time when the values provided were recorded.";
        }
        leaf client-address {
            type string;
            config false;
            description "The address of the connected client that is being monitored.";
        }
        uses tapi-common:global-class;
        description "Information on the monitoring of the use of a specific AvailableStream.";
    }
    grouping connection-protocol-details {
        leaf-list allowed-connection-protocols {
            type string;
            config false;
            description "Name of the allowed protocol.";
        }
        description "Details of the connection protocols available for the specific stream.";
    }
    grouping available-stream {
        leaf connection-address {
            type string;
            config false;
            description "Provides the address for the connection. 
                The format of the address and attachment mechanism will depend on the connection protocol defined in another attribute of this class.";
        }
        leaf stream-state {
            type stream-state;
            config false;
            description "The state of the stream.";
        }
        container supported-stream-type {
            uses supported-stream-type-ref;
            config false;
            description "Identifies the type of stream that is available for connection.";
        }
        leaf stream-id {
            type string;
            config false;
            description "The id of the stream.";
        }
        leaf connection-protocol {
            type string;
            config false;
            description "Names the connection protocol for this particular available stream.
                The connection protocol is chosen from the list of connection protocols identified in the referenced SupportedStreamType.";
        }
        uses tapi-common:global-class;
        description "Details of stream a stream that can be connected to by a client application.";
    }
    grouping stream-context {
        list available-stream {
            key 'uuid';
            config false;
            uses available-stream;
            description "none";
        }
        list supported-stream-type {
            key 'uuid';
            config false;
            uses supported-stream-type;
            description "none";
        }
        description "All streams relevant to the specific TapiContext.";
    }
    grouping supported-stream-type {
        leaf stream-type-name {
            type string;
            config false;
            description "Name of the stream type.";
        }
        leaf record-retention {
            type string;
            config false;
            description "Time in minutes.
                Statement of retention time and/or retention capacity in bytes.
                Key word 'FOREVER' means that records will never be removed from the log.
                May be overridden for particular cases of specific LogStorageStrategy (via augment).";
        }
        leaf segment-size {
            type string;
            config false;
            description "Size of sub-structuring of the log.";
        }
        leaf-list stream-type-content {
            type tapi-common:object-type;
            description "Identifies the classes that are supported through the stream. 
                The list may be a subset of the classes within the context.";
        }
        leaf log-storage-strategy {
            type log-storage-strategy;
            config false;
            description "Indicates the storage characteristics of the log supporting the stream.";
        }
        leaf log-record-strategy {
            type log-record-strategy;
            config false;
            description "Indicates the type of content of each log record.";
        }
        uses tapi-common:global-class;
        description "Definition of a supported stream type.";
    }
    grouping log-record {
        container log-record-header {
            config false;
            uses log-record-header;
            description "The header of the log record providing general parameters of the record common to all records.";
        }
        container log-record-body {
            config false;
            uses log-record-body;
            description "The body of the log record providing specific logged details.";
        }
        description "A specific atomic entry in a log.";
    }
    grouping log-record-body {
        container event-time-stamp {
            config false;
            uses approx-date-and-time;
            description "Time of the event at the origin of the event that triggered the generation of the record. 
                The structure allows for time uncertainty.";
        }
        leaf event-source {
            type event-source;
            config false;
            description "Indicates whether the source is controlled (under management control) or potentially chaotic (under resource control).
                The time characteristic of the source may be determined from the metadata describing the resource (e.g., a detector).
                Where there is an alternative (and probably more detailed) source of information on time characteristic this attribute can be omitted.";
        }
        list additional-event-info {
            key 'value-name';
            config false;
            uses tapi-common:name-and-value;
            description "Addition information related to the event such as change reason where changeReason would be the name and the value text would provide information on the reason for change.";
        }
        leaf-list parent-address {
            type string;
            config false;
            description "Where the entity is a local class this provides the ordered list of ids from the closest global class (a UUID cast as a string) to the direct parent (which may be the global class).
                The field can include all entities back to the Context and hence can be used for global classes where the tree is being represented in full.
                Gives the position of the entity in the address tree (usually containment) that is raising the event by providing the name/id values in the address of the parent.
                Is the sequence of named levels in the tree up to but excluding the entity of the notification. 
                It includes the device id where relevant.";
        }
        leaf record-content {
            type tapi-common:object-type;
            config false;
            description "The identifier of the object class in the record body detail.
                This property is used to control the conditional augmentation of the body with detail.";
        }
        description "The specific details of the Record.";
    }
    grouping log-record-header {
        leaf tapi-context {
            type tapi-common:uuid;
            config false;
            description "The identifier of the context.";
        }
        leaf token {
            type string;
            config false;
            description "A coded (and compact) form of the fullLogRecordOffsetId.
                This property is used to request streaming from a particular point (e.g., the last correctly handled record).";
        }
        list full-log-record-offset-id {
            key 'value-name';
            config false;
            min-elements 1;
            uses tapi-common:name-and-value;
            description "In a complex log solution there may be various parts to the log.
                The record token is a compressed form of log record reference.
                This property provides the verbose form 
                For example, it may include:
                - stream id
                - topic
                - partition
                - partition offset
                - sequence number (the offset is essentially the sequence number associated with the partition)";
        }
        leaf log-append-time-stamp {
            type tapi-common:date-and-time;
            config false;
            description "The time when the record was appended to the log.";
        }
        leaf entity-key {
            type string;
            config false;
            description "The identifier of the entity that is used in a Compacted log as the compaction key.
                The entityKey value, where appropriate, may be based upon the identifiers from the event source.
                It can be built from some specific detail combination that meets the necessary uniqueness and durability requirements.
                entityKey is the value used during compaction.
                Ideally it is a UUID format, if this can be formed from the source identifier.";
        }
        leaf record-type {
            type record-type;
            config false;
            description "The type of the record.
                Can be used to understand which elements of the record will be present.";
        }
        leaf record-authenticity-token {
            type string;
            config false;
            description "none";
        }
        description "The header of the log record providing general parameters of the record common to all records.";
    }
    notification stream-record {
        uses stream-record;
        description "none";
    }
    grouping stream-record {
        list log-record {
            config false;
            uses log-record;
            description "Each stream record may include a number of log records.";
        }
        description "The stream content.";
    }

    /**************************
    * package interfaces
    **************************/ 
    rpc connect-to-stream {
        description "none";
        input {
            leaf start-from-token {
                type string;
                description "none";
            }
            leaf connection-address {
                type string;
                description "none";
            }
        }
    }
    rpc get-available-stream-connection-details {
        description "none";
        output {
            list active-connections {
                uses available-stream;
                description "none";
            }
        }
    }
    rpc get-supported-stream-connection-types {
        description "none";
        output {
            list supported-stream-types {
                uses supported-stream-type;
                description "none";
            }
        }
    }

}
