module tapi-common {
    namespace "urn:onf:otcc:yang:tapi-common";
    prefix tapi-common;
    organization "ONF OTCC (Open Transport Configuration & Control) Project";
    contact "
         Project Web: <https://wiki.opennetworking.org/display/OTCC/TAPI>
         Project List: <mailto:transport-api@opennetworking.org>
         Editor: Karthik Sethuraman
                 <mailto:karthik.sethuraman@necam.com>";
    description "
        This module contains TAPI Common Model definitions.
        Source: TapiCommon.uml
        Copyright (c) 2018 Open Networking Foundation (ONF). All rights reserved.
        License: This module is distributed under the Apache License 2.0
        - The TAPI YANG models included in this TAPI release are a *normative* part of the TAPI SDK.
        - The YANG specifications have been generated from the corresponding UML model using the [ONF EAGLE UML2YANG mapping tool]
        <https://github.com/OpenNetworkingFoundation/EagleUmlYang>
        and further edited manually to comply with the [ONF IISOMI UML2YANG mapping guidelines]
        <https://wiki.opennetworking.org/display/OIMT/UML+-+YANG+Guidelines>
        - Status of YANG model artifacts can be determined by referring to the corresponding UML artifacts.
        As described in the UML models, some artifacts are considered *experimental*, and thus the corresponding YANG artifacts.
        - The ONF TAPI release process does not guarantee backward compatibility of YANG models across major versions of TAPI releases.
        The YANG model backward compatibility criteria are outlined in section 11 of <https://tools.ietf.org/html/rfc7950>.
        YANG models included in this release may not be backward compatible with previous TAPI releases.";
    revision 2019-03-31 {
        description "ONF Transport API version 2.2-RC1.
                   Changes included in this TAPI release (v2.2) are listed in
                  <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.2.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.2.0/UML>";
    }
    revision 2018-12-10 {
        description "ONF Transport API version 2.1.1.
                   Changes included in this TAPI release (v2.1.1) are listed in
                  <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.1.1.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.1.1/UML>";
    }
    revision 2018-10-16 {
        description "ONF Transport API version 2.1.0.
                   Changes included in this TAPI release (v2.1.0) are listed in
                  <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.1.0.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.1.0/UML>";
    }
    revision 2018-03-07 {
        description "ONF Transport API version 2.0.2
        This YANG module has been generated from the TAPI UML Model using the IISOMI-Eagle xmi2yang mapping tool.
        Changes in this revision: <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.0.2.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 6020, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.0.2/UML>";
    }
    revision 2018-02-16 {
        description "ONF Transport API version 2.0.1
        This YANG module has been generated from the TAPI UML Model using the IISOMI-Eagle xmi2yang mapping tool.
        Changes in this revision: <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.0.1.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 6020, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.0.1/UML>";
    }
    revision 2018-01-02 {
        description "ONF Transport API version 2.0.0
        This YANG module has been generated from the TAPI UML Model using the IISOMI-Eagle xmi2yang mapping tool.
        Changes in this revision: <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.0.0.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 6020, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.0.0/UML>";
    }
    /**************************
    * definitions of references
    **************************/
    grouping service-interface-point-ref {
        leaf service-interface-point-uuid {
            type leafref {
                path '/tapi-common:context/tapi-common:service-interface-point/tapi-common:uuid';
            }
            description "none";
        }
        description "none";
    }
    
    /**************************
    * package object-classes
    **************************/ 
    grouping admin-state-pac {
        leaf administrative-state {
            type administrative-state;
            description "The administration of managed objects operates independently of the operability and usage of managed objects and is described by the administrative state attribute. The administrative state is used by the operator to make a resource available for service, or to remove a resource from service.";
        }
        leaf operational-state {
            type operational-state;
            config false;
            description "The operational state gives the information about the real capability of a resource to provide or not provide service.";
        }
        leaf lifecycle-state {
            type lifecycle-state;
            config false;
            description "Used to track the planned deployment, allocation to clients and withdrawal of resources.";
        }
        description "Provides state attributes that are applicable to an entity that can be administered. Such an entity also has operational and lifecycle aspects.";
    }
    grouping global-class {
        leaf uuid {
            type uuid;
            description "UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable.
                An UUID carries no semantics with respect to the purpose or state of the entity.
                UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
                Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12} 
                Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6";
        }
        list name {
            key 'value-name';
            uses name-and-value;
            description "List of names. This value is unique in some namespace but may change during the life of the entity.
                A name carries no semantics with respect to the purpose of the entity.";
        }
        description "This class serves as the super class for all TAPI entities that can be directly retrieved by their ID. As such, these are first class entities and their ID is expected to be globally unique. ";
    }
    grouping lifecycle-state-pac {
        leaf lifecycle-state {
            type lifecycle-state;
            config false;
            description "Used to track the planned deployment, allocation to clients and withdrawal of resources.";
        }
        description "Provides state attributes for an entity that has lifecycle aspects only.";
    }
    grouping local-class {
        leaf local-id {
            type string;
            description "An identifier that is unique in the context of the GlobalClass from which it is inseparable.";
        }
        list name {
            key 'value-name';
            uses name-and-value;
            description "List of names. This value is unique in some namespace but may change during the life of the entity.
                A name carries no semantics with respect to the purpose of the entity.";
        }
        description "This class serves as the super class for all TAPI entities that are ancillary of first class entities, i.e. their ID is not expected to be globally unique. ";
    }
    grouping operational-state-pac {
        leaf operational-state {
            type operational-state;
            config false;
            description "The operational state gives the information about the real capability of a resource to provide or not provide service.";
        }
        leaf lifecycle-state {
            type lifecycle-state;
            config false;
            description "Used to track the planned deployment, allocation to clients and withdrawal of resources.";
        }
        description "Provides state attributes that are applicable to an entity that reflects operational aspects. Such an entity is expected to also have lifecycle aspects.";
    }
    container context {
        uses tapi-context;
/*        presence "Root container for all TAPI interaction";*/
        description "none";
    }
    grouping tapi-context {
        list service-interface-point {
            key 'uuid';
            uses service-interface-point;
            description "The ServiceInterfacePoint (SIP) instances belonging to this context.";
        }
        uses global-class;
        description "This object class represents the scope of control that a particular SDN controller has with respect to a particular network, (i.e., encompassing a designated set of interconnected (virtual) network elements).
            This class includes the list of Service Interface Points.
            This class can be augmented by specific contexts, e.g. topology context.";
    }
    grouping service-interface-point {
        leaf layer-protocol-name {
            type layer-protocol-name;
            config false;
            description "The layer protocol of the ServiceInterfacePoint (SIP).
                Usage of layerProtocolName [>1]  in the ServiceInterfacePoint should be considered experimental.";
        }
        leaf-list supported-layer-protocol-qualifier {
            type layer-protocol-qualifier;
            config false;
            min-elements 1;
            description "The supported sub-layer(s) or rate(s) of Layer Protocol.";
        }
        leaf direction {
            type port-direction;
            description "The orientation of flow at the (conceptual) port of the potentially supported ConnectivityService(s).
                If direction attribute is missing the ServiceInterfacePoint (SIP) instance is to be intended as 'BIDIRECTIONAL'";
        }
        uses global-class;
        uses admin-state-pac;
        uses capacity-pac;
        description "A Service Interface Point represents the network-interface-facing aspects of the edge-port functions that access the forwarding capabilities provided by the Node. Hence it provides a limited, simplified view of interest to external clients (e.g. shared addressing, capacity, resource availability, etc.), that enable the clients to request connectivity without the need to understand the provider network internals.";
    }
    grouping capacity-pac {
        container total-potential-capacity {
            config false;
            uses capacity;
            description "An optimistic view of the capacity of the entity assuming that any shared capacity is available to be taken.";
        }
        container available-capacity {
            config false;
            uses capacity;
            description "Capacity available to be assigned.";
        }
        description "Provides capacity related attributes.";
    }
    grouping termination-pac {
        leaf termination-direction {
            type termination-direction;
            config false;
            description "The overall directionality of the termination entity.";
        }
        leaf termination-state {
            type termination-state;
            config false;
            description "Indicates whether the layer is terminated and if so how.";
        }
        description "Specifies the direction and layer termination state of a termination entity, e.g. CEP, NEP.";
    }

    /**************************
    * package type-definitions
    **************************/ 
    identity LAYER_PROTOCOL_QUALIFIER {
        description "none";
    }
    identity LAYER_PROTOCOL_QUALIFIER_UNSPECIFIED {
        base LAYER_PROTOCOL_QUALIFIER;
        description "No sub-layer is specified.";
    }
    identity OBJECT_TYPE {
        description "none";
    }
    identity OBJECT_TYPE_SERVICE_INTERFACE_POINT {
        base OBJECT_TYPE;
        description "The ServiceInterfacePoint (SIP) class.";
    }
    identity PM_PARAMETER_NAME {
        description "none";
    }
    typedef administrative-state {
        type enumeration {
            enum LOCKED {
                description "Users are administratively prohibited from making use of the resource.";
            }
            enum UNLOCKED {
                description "Users are allowed to use the resource.";
            }
        }
        description "The possible values of the administrativeState.";
    }
    typedef date-and-time {
        type string;
        description "This primitive type defines the date and time according to ISO 8601 with the following structure:
            yyyyMMddhhmmss.s[Z|{+|-}HHMm] where:
            yyyy    0000..9999    year
            MM    01..12            month
            dd        01..31            day
            hh        00..23            hour
            mm    00..59            minute
            ss        00..60            second (60 for leap seconds)
            s        .0...9            tenth of second (set to .0 if EMS or NE cannot support this granularity)
            Z        Z                indicates UTC (rather than local time)
            {+|-}    + or -            delta from UTC
            HH        00..23            time zone difference in hours
            Mm    00..59            time zone difference in minutes.";
    }
    typedef directive-value {
        type enumeration {
            enum MINIMIZE {
                description "Directive to minimize.";
            }
            enum MAXIMIZE {
                description "Directive to maximize.";
            }
            enum ALLOW {
                description "Directive to allow.";
            }
            enum DISALLOW {
                description "Directive to disallow";
            }
            enum DONT_CARE {
                description "Directive is do not care.";
            }
        }
        description "Types of directives.";
    }
    typedef forwarding-direction {
        type enumeration {
            enum BIDIRECTIONAL {
                description "The fowarding entity supports BIDIRECTIONAL flows at all its (conceptual) ports (i.e. all ports have both an INPUT flow and an OUTPUT flow defined).";
            }
            enum UNIDIRECTIONAL {
                description "The forwarding entity has (conceptual) ports that are either INPUT or OUTPUT. It has no BIDIRECTIONAL (conceptual) ports.";
            }
            enum UNDEFINED_OR_UNKNOWN {
                description "Not a normal state. The system is unable to determine the correct value.";
            }
        }
        description "The directionality of a forwarding entity, e.g. Link, ConnectivityService, Connection, PathComputationService, Path.";
    }
    typedef layer-protocol-name {
        type enumeration {
            enum ODU {
                description "Models the ODU layer as per ITU-T G.872";
            }
            enum ETH {
                description "Models the ETH layer as per ITU-T G.8010";
            }
            enum DSR {
                description "Models a Digital Signal of an unspecified rate (Layer 1 coding functions). This value can be used when the intent is to represent a generic digital layer signal without making any statement on its format or overhead (processing) capabilities.";
            }
            enum PHOTONIC_MEDIA {
                description "Models the optical signal and media channel layer as per ITU-T G.807";
            }
        }
        description "Provides a controlled list of layer protocol names and indicates the naming authority.
            Note that it is expected that attributes will be added to this structure to convey the naming authority name, the name of the layer protocol using a human readable string and any particular standard reference.
            ";
    }
    typedef lifecycle-state {
        type enumeration {
            enum PLANNED {
                description "The resource is planned but is not present in the network.";
            }
            enum POTENTIAL_AVAILABLE {
                description "The supporting resources are present in the network but are shared with other clients; or require further configuration before they can be used; or both.
                    When a potential resource is configured and allocated to a client it is moved to the INSTALLED state for that client.
                    If the potential resource has been consumed (e.g. allocated to another client) it is moved to the POTENTIAL_BUSY state for all other clients.";
            }
            enum POTENTIAL_BUSY {
                description "The supporting resources are present in the network but have been allocated to other clients.";
            }
            enum INSTALLED {
                description "The resource is present in the network and is capable of providing the service expected.";
            }
            enum PENDING_REMOVAL {
                description "The resource has been marked for removal.";
            }
        }
        description "The possible values of the lifecycleState.";
    }
    grouping name-and-value {
        leaf value-name {
            type string;
            description "The name of the value. Optional, the value need not to have a name.";
        }
        leaf value {
            type string;
            description "The specific value.";
        }
        description "A scoped name-value pair.";
    }
    typedef operational-state {
        type enumeration {
            enum DISABLED {
                description "The resource is unable to meet the SLA of the user of the resource. If no (explicit) SLA is defined the resource is disabled if it is totally inoperable and unable to provide service to the user.";
            }
            enum ENABLED {
                description "The resource is partially or fully operable and available for use.";
            }
        }
        description "The possible values of the operationalState.";
    }
    typedef port-direction {
        type enumeration {
            enum BIDIRECTIONAL {
                description "The Port has both an INPUT flow and an OUTPUT flow defined.";
            }
            enum INPUT {
                description "The port only has definition for a flow into the forwarding entity, (i.e. an ingress flow of e.g Link or Connection, hence an egress flow of NEP or CEP, CSEP etc.).";
            }
            enum OUTPUT {
                description "The port only has definition for a flow out of the forwarding entity (i.e. an egress flow of e.g. Link or Connection, hence an ingress flow of NEP or CEP, CSEP etc.).";
            }
            enum UNIDENTIFIED_OR_UNKNOWN {
                description "Not a normal state. The system is unable to determine the correct value.";
            }
        }
        description "The orientation of flow at the (conceptual) port of a forwarding entity, e.g. Link, ConnectivityService, Connection, PathComputationService, Path, VirtualNetworkService.";
    }
    typedef port-role {
        type enumeration {
            enum SYMMETRIC {
                description "A port that can exchange flows (e.g. distinct packet flows) with any other port(s) in a forwarding entity.
                    The SYMMETRIC role applies to point to point and multipoint to multipoint connection schemes.";
            }
            enum ROOT {
                description "A port that can exchange flows (e.g. distinct packet flows) with any other port(s) in a forwarding entity.
                    The ROOT role is unique to the Rooted Multipoint connection scheme.";
            }
            enum LEAF {
                description "A port that can only exchange flows (e.g. distinct packet flows) with any other ROOT or TRUNK port(s) in a forwarding entity.
                    The LEAF role is unique to the Rooted Multipoint connection scheme.";
            }
            enum TRUNK {
                description "The TRUNK role is unique to the ENNI involved in a Rooted Multipoint connection scheme. It provides a way to extend the concept of ROOT and LEAF bidirectionally across the ENNI without having to create multiple ports (Leaves and Roots) and hairpinning from one to the other.";
            }
            enum UNKNOWN {
                description "Not a normal state. The system is unable to determine the correct value.";
            }
        }
        description "The role of a (conceptual) port of a forwarding entity, e.g. Link, ConnectivityService, Connection, PathComputationService, Path, VirtualNetworkService.";
    }
    typedef termination-direction {
        type enumeration {
            enum BIDIRECTIONAL {
                description "A termination entity with both SINK and SOURCE flows.";
            }
            enum SINK {
                description "The flow is up the layer stack from the server side to the client side. 
                    Considering an example of a termination function within the termination entity, a SINK flow:
                    1) will arrive at the base of the termination function (the server side) where it is essentially at an INPUT to the termination function,
                    2) then will be decoded and deconstructed, 
                    3) then the relevant parts of the flow will be sent out of the termination function (the client side) where it is essentially at an OUTPUT from the termination function.
                    A SINK termination function is one that only supports a SINK flow.
                    A SINK termination function can be bound to an OUTPUT (conceptual) port of a forwarding entity, e.g. Link, ConnectivityService, Connection, PathComputationService, Path.";
            }
            enum SOURCE {
                description "The flow is down the layer stack from the server side to the client side. 
                    Considering an example of a termination function within the termination entity, a SOURCE flow:
                    1) will arrive at at the top of the termination function (the client side) where it is essentially at an INPUT to the termination function,
                    2) then will be assembled with various overheads etc and will be coded,
                    3) then the coded form of the assembly of flow will be sent out of the termination function (the server side) where it is essentially at an OUTPUT from the termination function.
                    A SOURCE termination is one that only supports a SOURCE flow.
                    A SOURCE termination can be bound to an INPUT (conceptual) port of a forwarding entity, e.g. Link, ConnectivityService, Connection, PathComputationService, Path.";
            }
            enum UNDEFINED_OR_UNKNOWN {
                description "Not a normal state. The system is unable to determine the correct value.";
            }
        }
        description "The directionality of a termination entity, e.g. CEP, NEP.";
    }
    typedef termination-state {
        type enumeration {
            enum CAN_NEVER_TERMINATE {
                description "A non-flexible case that can never be terminated.";
            }
            enum NOT_TERMINATED {
                description "A flexible termination that can terminate but is currently not terminated.";
            }
            enum TERMINATED_SERVER_TO_CLIENT_FLOW {
                description "A flexible termination that is currently terminated for server to client flow only.";
            }
            enum TERMINATED_CLIENT_TO_SERVER_FLOW {
                description "A flexible termination that is currently terminated for client to server flow only.";
            }
            enum TERMINATED_BIDIRECTIONAL {
                description "A flexible termination that is currently terminated in both directions of flow.";
            }
            enum PERMANENTLY_TERMINATED {
                description "A non-flexible termination that is always terminated (in both directions of flow for a bidirectional case and in the one direction of flow for both unidirectional cases).";
            }
            enum TERMINATION_STATE_UNKNOWN {
                description "Not a normal state. The system is unable to determine the correct value.";
            }
        }
        description "Provides support for the range of behaviours and specific states that the termination function of a termination entity can take with respect to the termination of the signal.";
    }
    typedef uuid {
        type string;
        description "The univeral ID value where the mechanism for generation is defned by some authority not directly referenced in the structure.
            UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
            Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12} 
            Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6";
    }
    grouping capacity {
        container total-size {
            uses capacity-value;
            description "Total capacity of the entity. In case of bandwidthProfile, this is expected to be the same as the committedInformationRate.";
        }
        description "Information on capacity of a particular entity.";
    }
    grouping capacity-value {
        leaf value {
            type uint64;
            description "The specific value of the capacity.";
        }
        leaf unit {
            type capacity-unit;
            description "The specific unit of measurement of the capacity.";
        }
        description "The Capacity (Bandwidth) values that are applicable for digital layers.";
    }
    typedef capacity-unit {
        type enumeration {
            enum TB {
                description "Indicates that the integer CapacityValue is in TeraBytes";
            }
            enum TBPS {
                description "Indicates that the integer CapacityValue is in Terabit-per-second";
            }
            enum GB {
                description "Indicates that the integer CapacityValue is in GigaBytes";
            }
            enum GBPS {
                description "Indicates that the integer CapacityValue is in Gigabit-per-second";
            }
            enum MB {
                description "Indicates that the integer CapacityValue is in MegaBytes";
            }
            enum MBPS {
                description "Indicates that the integer CapacityValue is in Megabit-per-second";
            }
            enum KB {
                description "Indicates that the integer CapacityValue is in KiloBytes";
            }
            enum KBPS {
                description "Indicates that the integer CapacityValue is in Kilobit-per-second";
            }
            enum GHz {
                description "Indicates that the integer CapacityValue is in gigahertz (spectrum)";
            }
            enum MHz {
                description "Indicates that the integer CapacityValue is in megahertz (spectrum)";
            }
        }
        description "Units of measurement of the capacity.";
    }
    grouping time-range {
        leaf start-time {
            type date-and-time;
            description "Date and time of the range start.";
        }
        leaf end-time {
            type date-and-time;
            description "Date and time of the range end.";
        }
        description "Range of time.";
    }
    grouping time-period {
        leaf value {
            type uint64;
            description "The specific value of the time period.";
        }
        leaf unit {
            type time-unit;
            description "The unit of measurement of the time period.";
        }
        description "Period of time.";
    }
    typedef time-unit {
        type enumeration {
            enum YEARS {
                description "none";
            }
            enum MONTHS {
                description "none";
            }
            enum DAYS {
                description "none";
            }
            enum HOURS {
                description "none";
            }
            enum MINUTES {
                description "none";
            }
            enum SECONDS {
                description "none";
            }
            enum MILLISECONDS {
                description "none";
            }
            enum MICROSECONDS {
                description "none";
            }
            enum NANOSECONDS {
                description "none";
            }
            enum PICOSECONDS {
                description "none";
            }
        }
        description "Units of measurement of the time.";
    }
    grouping time-interval {
        list period {
            key 'unit';
            min-elements 1;
            max-elements 5;
            uses time-period;
            description "The specific interval of time. Each TimePeriod occurrence specifies a duration in years, months, days, hours, minutes etc. 
                The 1..5 occurrences complies with Q.821.
                ITU-T Q.821 (02/2000):
                TimeInterval ::= SEQUENCE {
                day [0] INTEGER (0..31) DEFAULT 0,
                hour [1] INTEGER (0..23) DEFAULT 0,
                minute [2] INTEGER (0..59) DEFAULT 0,
                second [3] INTEGER (0..59) DEFAULT 0,
                msec [4] INTEGER (0..999) DEFAULT 0 }
                Examples: 
                A duration of 1 hour, 15 minutes and 30 seconds should be coded as 3 occurrences of TimePeriod:
                - HOURS; 1
                - MINUTES; 15
                - SECONDS; 30
                A duration of 1550 milliseconds as two occurrences of TimePeriod:
                - SECONDS; 1
                - MILLISECONDS: 550";
        }
        description "Interval of time, duration.
            Q.821: The Interval attribute type indicates the time between occurrences of a given activity described by an instance of the Management Operations Schedule object class.
            The interval can be specified in seconds, minutes, hours, or days.
            ";
    }
    typedef layer-protocol-qualifier {
        type identityref {
            base LAYER_PROTOCOL_QUALIFIER;
        }
        description "This enumeration is used to qualify the sub-layers (if applicable) for a specific LayerProtocol.
            This extensible enumeration includes only the 'UNSPECIFIED' entry in the common module and can be augmented with layer-specific values in the respective technology-specific modules.";
    }
    typedef mac-address {
        type string;
        description "Pattern: '[0-9a-fA-F]{2}(-[0-9a-fA-F]{2}){5}'
            Description: 'The mac-address type represents a MAC address in the canonical format and hexadecimal format specified by IEEE Std 802. The canonical representation uses lowercase characters. The hexadecimal representation uses uppercase characters.'";
    }
    typedef binary-type {
        type string;
        description "Represents any binary data, i.e., a sequence of octets.
            A binary type can be restricted by a length which defines the number of octets it contains.";
    }
    typedef timeticks {
        type string;
        description "Type uint32.
            This type represents a non-negative integer that represents the time, modulo 2^32 (4294967296 decimal), in hundredths of a second between two epochs.";
    }
    typedef object-type {
        type identityref {
            base OBJECT_TYPE;
        }
        description "The list of TAPI Global Object Class types on which Notification signals can be raised.
            This extensible enumeration includes only the 'SERVICE_INTERFACE_POINT' entry in the common module and can be augmented with specific object types/classes in the other modules.";
    }
    grouping pm-parameter-value {
        leaf pm-parameter-int-value {
            type uint64;
            description "Integer value, e.g. for counters.";
        }
        leaf pm-parameter-real-value {
            type decimal64 {
                fraction-digits 7;
            }
            description "Real value, e.g. for gauges.";
        }
        description "PM metric value.";
    }
    typedef pm-parameter-name {
        type identityref {
            base PM_PARAMETER_NAME;
        }
        description "The PM metric names.
            This extensible enumeration can be augmented with specific PM metric names in the other modules.";
    }
    grouping pm-parameter {
        leaf pm-parameter-name {
            type pm-parameter-name;
            description "The name of the PM metric. Technology specific modules may define specific PM metrics.";
        }
        container pm-parameter-value {
            uses pm-parameter-value;
            description "The value of the PM metric.";
        }
        description "PM metric name and value.";
    }

    /**************************
    * package interfaces
    **************************/ 
    rpc get-service-interface-point-details {
        description "none";
        input {
            leaf uuid {
                type uuid;
                description "UUID of the ServiceInterfacePoint (SIP) instance.
                    UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable.
                    An UUID carries no semantics with respect to the purpose or state of the entity.
                    UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
                    Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12} 
                    Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6";
            }
        }
        output {
            container sip {
                uses service-interface-point;
                description "The requested SIP instance.";
            }
        }
    }
    rpc get-service-interface-point-list {
        description "none";
        output {
            list sip {
                key 'uuid';
                uses service-interface-point;
                description "The requested list of SIP instances.";
            }
        }
    }
    rpc update-service-interface-point {
        description "none";
        input {
            leaf uuid {
                type uuid;
                description "UUID of the ServiceInterfacePoint (SIP) instance.
                    UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable.
                    An UUID carries no semantics with respect to the purpose or state of the entity.
                    UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
                    Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12} 
                    Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6";
            }
            leaf state {
                type administrative-state;
                description "The requested update of Administrative State.";
            }
        }
    }

}
