module tapi-topology {
    yang-version "1.1";
    namespace "urn:onf:otcc:yang:tapi-topology";
    prefix tapi-topology;
    import tapi-common {
        prefix tapi-common;
    }
    import tapi-notification {
        prefix tapi-notification;
    }
    import tapi-streaming {
        prefix tapi-streaming;
    }
    organization "ONF OTCC (Open Transport Configuration & Control) Project";
    contact "
         Project Web: <https://wiki.opennetworking.org/display/OTCC/TAPI>
         Project List: <mailto:transport-api@opennetworking.org>
         Editor: Karthik Sethuraman <mailto:karthik.sethuraman@necam.com>
         Andrea Mazzini <mailto:andrea.mazzini@nokia.com>
         Arturo Mayoral <mailto:arturo.mayoral@telefonica.com>
         Nigel Davis <mailto:ndavis@ciena.com>
         Ramon Casellas <mailto:ramon.casellas@cttc.es>";
    description "
        This module contains TAPI Topology Model definitions.
        Source: TapiTopology.uml
        - The TAPI YANG models included in this TAPI release are a *normative* part of the TAPI SDK.
        - The YANG specifications have been generated from the corresponding UML model using the [ONF EAGLE UML2YANG mapping tool]
        <https://github.com/OpenNetworkingFoundation/EagleUmlYang>
        and further edited manually to comply with the [ONF IISOMI UML2YANG mapping guidelines]
        <https://wiki.opennetworking.org/display/OIMT/UML+-+YANG+Guidelines>
        - Status of YANG model artifacts can be determined by referring to the corresponding UML artifacts.
        As described in the UML models, some artifacts are considered *experimental*, and thus the corresponding YANG artifacts.
        - The ONF TAPI release process does not guarantee backward compatibility of YANG models across major versions of TAPI releases.
        The YANG model backward compatibility criteria are outlined in section 11 of <https://tools.ietf.org/html/rfc7950>.
        YANG models included in this release may not be backward compatible with previous TAPI releases.
        Copyright (c) 2022 Open Networking Foundation (ONF). All rights reserved.
        License: This module is distributed under the Apache License 2.0.";
    revision 2022-11-21 {
        description "ONF Transport API version 2.4.0 RC1.
                   Changes included in this TAPI release (v2.4.0) are listed in
                   <https://wiki.opennetworking.org/display/OTCC/TAPI+Roadmap+2022-2023>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.4.0-RC1/UML>";
    }
    revision 2021-09-24 {
        description "ONF Transport API version 2.3.1.
                   Changes included in this TAPI release (v2.3.1) are listed in
                   <https://wiki.opennetworking.org/display/OTCC/TAPI+Roadmap+2021>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.3.1/UML>";
    }
    revision 2021-08-04 {
        description "ONF Transport API version 2.3.
                   Changes included in this TAPI release (v2.3) are listed in
                   <https://wiki.opennetworking.org/display/OTCC/TAPI+Roadmap+2021>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.3/UML>";
    }
    revision 2021-05-24 {
        description "ONF Transport API version 2.3 RC1.
                   Changes included in this TAPI release (v2.3) are listed in
                   <https://wiki.opennetworking.org/display/OTCC/TAPI+Roadmap+2021>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.3/UML>";
    }
    revision 2020-04-23 {
        description "ONF Transport API version 2.1.3.
                   Changes included in this TAPI release (v2.1.3) are listed in
                   <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop_v2_1/CHANGE_LOG/change-log.2.1.3.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.1.3/UML>";
    }
    revision 2019-07-16 {
        description "ONF Transport API version 2.1.2.
                   Changes included in this TAPI release (v2.1.2) are listed in
                   <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop_v2_1/CHANGE_LOG/change-log.2.1.2.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.1.2/UML>";
    }
    revision 2019-03-31 {
        description "ONF Transport API version 2.2-RC1.
                   Changes included in this TAPI release (v2.2) are listed in
                  <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.2.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.2.0/UML>";
    }
    revision 2018-12-10 {
        description "ONF Transport API version 2.1.1.
                   Changes included in this TAPI release (v2.1.1) are listed in
                  <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.1.1.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.1.1/UML>";
    }
    revision 2018-10-16 {
        description "ONF Transport API version 2.1.0.
                   Changes included in this TAPI release (v2.1.0) are listed in
                  <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.1.0.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.1.0/UML>";
    }
    revision 2018-03-07 {
        description "ONF Transport API version 2.0.2
        This YANG module has been generated from the TAPI UML Model using the IISOMI-Eagle xmi2yang mapping tool.
        Changes in this revision: <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.0.2.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 6020, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.0.2/UML>";
    }
    revision 2018-02-16 {
        description "ONF Transport API version 2.0.1
        This YANG module has been generated from the TAPI UML Model using the IISOMI-Eagle xmi2yang mapping tool.
        Changes in this revision: <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.0.1.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 6020, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.0.1/UML>";
    }
    revision 2018-01-02 {
        description "ONF Transport API version 2.0.0
        This YANG module has been generated from the TAPI UML Model using the IISOMI-Eagle xmi2yang mapping tool.
        Changes in this revision: <https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.0.0.md>";
        reference "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 6020, RFC 6087 and ONF TAPI UML model
                  <https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.0.0/UML>";
    }
    augment "/tapi-common:context" {
        container topology-context {
            uses topology-context;
            description "Augments the base TAPI Context with TopologyService model.";
        }
        description "Augments the base TAPI Context with TopologyService model.";
    }
    augment "/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
        when 'derived-from-or-self(tapi-streaming:record-content, "TOPOLOGY_OBJECT_TYPE_NODE")';
        container node {
            uses node;
            description "none";
        }
        description "none";
    }
    augment "/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
        when 'derived-from-or-self(tapi-streaming:record-content, "TOPOLOGY_OBJECT_TYPE_TOPOLOGY")';
        container topology {
            uses topology;
            description "none";
        }
        description "none";
    }
    augment "/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
        when 'derived-from-or-self(tapi-streaming:record-content, "TOPOLOGY_OBJECT_TYPE_LINK")';
        container link {
            uses link;
            description "none";
        }
        description "none";
    }
    augment "/tapi-common:context/tapi-notification:notification-context/tapi-notification:event-notification" {
        when 'derived-from-or-self(tapi-notification:target-object-type, "TOPOLOGY_OBJECT_TYPE_NODE")';
        container node {
            uses node;
            description "none";
        }
        description "none";
    }
    augment "/tapi-common:context/tapi-notification:notification-context/tapi-notification:event-notification" {
        when 'derived-from-or-self(tapi-notification:target-object-type, "TOPOLOGY_OBJECT_TYPE_TOPOLOGY")';
        container topology {
            uses topology;
            description "none";
        }
        description "none";
    }
    augment "/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
        when 'derived-from-or-self(tapi-streaming:record-content, "TOPOLOGY_OBJECT_TYPE_NODE_EDGE_POINT")';
        container node-edge-point {
            uses node-edge-point;
            description "none";
        }
        description "none";
    }
    augment "/tapi-common:context/tapi-notification:notification-context/tapi-notification:event-notification" {
        when 'derived-from-or-self(tapi-notification:target-object-type, "TOPOLOGY_OBJECT_TYPE_NODE_EDGE_POINT")';
        container node-edge-point {
            uses node-edge-point;
            description "none";
        }
        description "none";
    }
    augment "/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
        when 'derived-from-or-self(tapi-streaming:record-content, "TOPOLOGY_OBJECT_TYPE_NETWORK_TOPOLOGY_SERVICE")';
        container network-topology-service {
            uses network-topology-service;
            description "none";
        }
        description "none";
    }
    augment "/tapi-common:context/tapi-notification:notification-context/tapi-notification:event-notification" {
        when 'derived-from-or-self(tapi-notification:target-object-type, "TOPOLOGY_OBJECT_TYPE_NETWORK_TOPOLOGY_SERVICE")';
        container network-topology-service {
            uses network-topology-service;
            description "none";
        }
        description "none";
    }
    augment "/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
        when 'derived-from-or-self(tapi-streaming:record-content, "TOPOLOGY_OBJECT_TYPE_NODE_RULE_GROUP")';
        container node-rule-group {
            uses node-rule-group;
            description "none";
        }
        description "none";
    }
    augment "/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
        when 'derived-from-or-self(tapi-streaming:record-content, "TOPOLOGY_OBJECT_TYPE_INTER_RULE_GROUP")';
        container inter-rule-group {
            uses inter-rule-group;
            description "none";
        }
        description "none";
    }
    augment "/tapi-common:context/tapi-notification:notification-context/tapi-notification:event-notification" {
        when 'derived-from-or-self(tapi-notification:target-object-type, "TOPOLOGY_OBJECT_TYPE_RULE")';
        container rule {
            uses rule;
            description "none";
        }
        description "none";
    }
    augment "/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
        when 'derived-from-or-self(tapi-streaming:record-content, "TOPOLOGY_OBJECT_TYPE_RULE")';
        container rule {
            uses rule;
            description "none";
        }
        description "none";
    }
    augment "/tapi-common:context/tapi-notification:notification-context/tapi-notification:event-notification" {
        when 'derived-from-or-self(tapi-notification:target-object-type, "TOPOLOGY_OBJECT_TYPE_INTER_RULE_GROUP")';
        container inter-rule-group {
            uses inter-rule-group;
            description "none";
        }
        description "none";
    }
    augment "/tapi-common:context/tapi-notification:notification-context/tapi-notification:event-notification" {
        when 'derived-from-or-self(tapi-notification:target-object-type, "TOPOLOGY_OBJECT_TYPE_LINK")';
        container link {
            uses link;
            description "none";
        }
        description "none";
    }
    augment "/tapi-notification:event-notification" {
        when 'derived-from-or-self(tapi-notification:target-object-type, "TOPOLOGY_OBJECT_TYPE_NODE")';
        container node {
            uses node;
            description "none";
        }
        description "none";
    }
    augment "/tapi-notification:event-notification" {
        when 'derived-from-or-self(tapi-notification:target-object-type, "TOPOLOGY_OBJECT_TYPE_TOPOLOGY")';
        container topology {
            uses topology;
            description "none";
        }
        description "none";
    }
    augment "/tapi-notification:event-notification" {
        when 'derived-from-or-self(tapi-notification:target-object-type, "TOPOLOGY_OBJECT_TYPE_NODE_EDGE_POINT")';
        container node-edge-point {
            uses node-edge-point;
            description "none";
        }
        description "none";
    }
    augment "/tapi-notification:event-notification" {
        when 'derived-from-or-self(tapi-notification:target-object-type, "TOPOLOGY_OBJECT_TYPE_NETWORK_TOPOLOGY_SERVICE")';
        container network-topology-service {
            uses network-topology-service;
            description "none";
        }
        description "none";
    }
    augment "/tapi-notification:event-notification" {
        when 'derived-from-or-self(tapi-notification:target-object-type, "TOPOLOGY_OBJECT_TYPE_RULE")';
        container rule {
            uses rule;
            description "none";
        }
        description "none";
    }
    augment "/tapi-notification:event-notification" {
        when 'derived-from-or-self(tapi-notification:target-object-type, "TOPOLOGY_OBJECT_TYPE_LINK")';
        container link {
            uses link;
            description "none";
        }
        description "none";
    }
    augment "/tapi-common:context/tapi-notification:notification-context/tapi-notification:event-notification" {
        when 'derived-from-or-self(tapi-notification:target-object-type, "TOPOLOGY_OBJECT_TYPE_NODE_RULE_GROUP")';
        container node-rule-group {
            uses node-rule-group;
            description "none";
        }
        description "none";
    }
    augment "/tapi-notification:event-notification" {
        when 'derived-from-or-self(tapi-notification:target-object-type, "TOPOLOGY_OBJECT_TYPE_NODE_RULE_GROUP")';
        container node-rule-group {
            uses node-rule-group;
            description "none";
        }
        description "none";
    }
    augment "/tapi-notification:event-notification" {
        when 'derived-from-or-self(tapi-notification:target-object-type, "TOPOLOGY_OBJECT_TYPE_INTER_RULE_GROUP")';
        container inter-rule-group {
            uses inter-rule-group;
            description "none";
        }
        description "none";
    }
    /**************************
    * definitions of references
    **************************/
    grouping topology-ref {
        leaf topology-uuid {
            type leafref {
                path '/tapi-common:context/tapi-topology:topology-context/tapi-topology:topology/tapi-topology:uuid';
            }
            description "none";
        }
        description "none";
    }
    grouping link-ref {
        uses topology-ref;
        leaf link-uuid {
            type leafref {
                path '/tapi-common:context/tapi-topology:topology-context/tapi-topology:topology/tapi-topology:link/tapi-topology:uuid';
            }
            description "none";
        }
        description "none";
    }
    grouping node-ref {
        uses topology-ref;
        leaf node-uuid {
            type leafref {
                path '/tapi-common:context/tapi-topology:topology-context/tapi-topology:topology/tapi-topology:node/tapi-topology:uuid';
            }
            description "none";
        }
        description "none";
    }
    grouping node-edge-point-ref {
        uses node-ref;
        leaf node-edge-point-uuid {
            type leafref {
                path '/tapi-common:context/tapi-topology:topology-context/tapi-topology:topology/tapi-topology:node/tapi-topology:owned-node-edge-point/tapi-topology:uuid';
            }
            description "none";
        }
        description "none";
    }
    grouping node-rule-group-ref {
        uses node-ref;
        leaf node-rule-group-uuid {
            type leafref {
                path '/tapi-common:context/tapi-topology:topology-context/tapi-topology:topology/tapi-topology:node/tapi-topology:node-rule-group/tapi-topology:uuid';
            }
            description "none";
        }
        description "none";
    }
    /**************************
    * package object-classes
    **************************/ 
    grouping link {
        list node-edge-point {
            uses node-edge-point-ref;
            key 'topology-uuid node-uuid node-edge-point-uuid';
            config false;
            min-elements 2;
            description "The NEPs connected by the Link.";
        }
        leaf-list layer-protocol-name {
            type tapi-common:layer-protocol-name;
            config false;
            min-elements 1;
            description "The layer protocol(s) of the Link.";
        }
        leaf direction {
            type tapi-common:forwarding-direction;
            config false;
            description "The directionality of the Link.";
        }
        container resilience-type {
            uses resilience-type;
            description "The underlying resilience type of the Link.";
        }
        uses tapi-common:global-class;
        uses tapi-common:admin-state-pac;
        uses tapi-common:capacity-pac;
        uses transfer-cost-pac;
        uses transfer-integrity-pac;
        uses transfer-timing-pac;
        uses risk-parameter-pac;
        uses validation-pac;
        uses layer-protocol-transition-pac;
        description "A Link is a topological entity which is an abstract representation of the effective adjacency between two or more Node instances (specifically NodeEdgePoint instances) in a Topology.";
    }
    grouping node {
        leaf-list layer-protocol-name {
            type tapi-common:layer-protocol-name;
            config false;
            min-elements 1;
            description "The layer protocol(s) of the (multi-layer) Node.";
        }
        list owned-node-edge-point {
            key 'uuid';
            config false;
            uses node-edge-point;
            description "The NEPs belonging to / owned by this Node.
                By convention, only the Node instances at the lowest partitioning level 'own' the NEPs.
                In other words, each and every NEP instance is owned by a Node at the lowest partitioning level.";
        }
        list aggregated-node-edge-point {
            uses node-edge-point-ref;
            key 'topology-uuid node-uuid node-edge-point-uuid';
            config false;
            description "The NEPs aggregated by this Node.
                By convention, only the Node instances which are not at the lowest partitioning level 'aggregate' the NEPs.
                In other words, each and every NEP instance is owned by a Node at the lowest partitioning level. A subset of NEP instances may be aggregated by Nodes at higher partitioning levels.";
        }
        list node-rule-group {
            key 'uuid';
            config false;
            uses node-rule-group;
            description "The Node rules applicable to this Node.";
        }
        list inter-rule-group {
            key 'uuid';
            config false;
            uses inter-rule-group;
            description "none";
        }
        container encap-topology {
            uses topology-ref;
            config false;
            description "A Node may encapsulate one Topology instance, which in turn encompasses Nodes at lower partitioning level.";
        }
        list profile {
            uses tapi-common:profile-ref;
            key 'profile-uuid';
            config false;
            description "none";
        }
        container risk-parameter-pac {
            uses risk-parameter-pac;
            description "none";
        }
        uses tapi-common:global-class;
        uses tapi-common:admin-state-pac;
        uses tapi-common:capacity-pac;
        uses transfer-cost-pac;
        uses transfer-integrity-pac;
        uses transfer-timing-pac;
        description "The Node is a topological entity which is an abstract representation of the forwarding capabilities (of transport characteristic information) of a particular set of network resources.
            It is described in terms of the aggregation of set of ports (NodeEdgePoint) belonging to those network resources and the potential to enable forwarding of information between those edge ports.
            At the lowest level of recursion, a Node may represent a switch matrix (i.e., a fabric) in an equipment.";
    }
    grouping topology {
        list node {
            key 'uuid';
            config false;
            uses node;
            description "The list of Nodes which the Topology encompass.";
        }
        list link {
            key 'uuid';
            config false;
            uses link;
            description "The list of Links which the Topology encompass.";
        }
        leaf-list layer-protocol-name {
            type tapi-common:layer-protocol-name;
            config false;
            min-elements 1;
            description "The layer protocol(s) of the (multi-layer) Topology.";
        }
        list boundary-node-edge-point {
            uses node-edge-point-ref;
            key 'topology-uuid node-uuid node-edge-point-uuid';
            config false;
            description "This list is applicable only in case of a 'top' Topology (i.e. a Topology which is not encapsulated in a Node) which does not encompass a single Node.
                In this case, the list identifies the NEPs which are at the boundary of the Topology, which can be a subset of all the NEPs belonging to encompassed Nodes.
                It is expected that these boundary NEPs have an associated SIP to allow the provisioning of ConnectivityServices spanning the whole Topology.";
        }
        uses tapi-common:global-class;
        description "The Topology is an abstract representation of the topological aspects of a particular set of network resources. It is described in terms of the underlying topological network of Node and Link instances that enable the forwarding capabilities of that particular set of network resources.";
    }
    grouping layer-protocol-transition-pac {
        leaf-list transitioned-layer-protocol-name {
            type string;
            min-elements 2;
            description "Provides the ordered structure of layer protocol transitions encapsulated in the Link.
                The list starts with the client side as the first entry and includes all layer-protocol names (hence the smallest number is 2 as otherwise the Link is not transitional).
                The ordering relates also to the (conceptual) port role (which emphasizes the orientation).";
        }
        description "Relevant for a Link that is formed by abstracting one or more termination entities (in a stack) to focus on the flow and deemphasize the protocol transformation.
            This abstraction is relevant when considering multi-layer routing and the protocol transformation is not too complex, e.g. there is not multiplexing.
            This Pac provides the relevant abstractions of the embedded termination entities: The layer protocols of the embedded termination entities and the order of their application to the signal is still relevant and need to be accounted for.
            Links that included details in this Pac are often referred to as Transitional Links.";
    }
    grouping node-edge-point {
        leaf layer-protocol-name {
            type tapi-common:layer-protocol-name;
            config false;
            description "The layer protocol of the NodeEdgePoint (NEP).";
        }
        list supported-cep-layer-protocol-qualifier-instances {
            config false;
            uses tapi-common:supported-layer-protocol-qualifier;
            description "The potentially supported protocols and flows.
                In ITU-T terms, the potentially supported adaptation and termination functions. ";
        }
        list available-cep-layer-protocol-qualifier-instances {
            config false;
            uses tapi-common:supported-layer-protocol-qualifier;
            description "none";
        }
        list supported-payload-structure {
            uses tapi-common:payload-structure;
            description "none";
        }
        list available-payload-structure {
            config false;
            uses tapi-common:payload-structure;
            description "More detailed description of available capability than 'supportedCepLayerProtocol'.";
        }
        list aggregated-node-edge-point {
            uses node-edge-point-ref;
            key 'topology-uuid node-uuid node-edge-point-uuid';
            config false;
            description "A NodeEdgePoint (NEP) instance may aggregate one or more other NEP instances for e.g. pooling purposes, when a set of NEP instances are equivalent for usage.";
        }
        list mapped-service-interface-point {
            uses tapi-common:service-interface-point-ref;
            key 'service-interface-point-uuid';
            config false;
            description "A NodeEdgePoint (NEP) may be associated to a ServiceInterfacePoint (SIP), i.e. when the NEP is the resource oriented view of a SIP.
                NEP mapped to more than one SIP (slicing/virtualizing) or a SIP mapped to more than one NEP (load balancing/resilience) should be considered experimental.";
        }
        container inter-domain-plug-id-pac {
            config false;
            uses inter-domain-plug-id-pac;
            description "ENNI Identifier.";
        }
        list node-rule-group {
            uses node-rule-group-ref;
            key 'topology-uuid node-uuid node-rule-group-uuid';
            config false;
            description "none";
        }
        list profile {
            uses tapi-common:profile-ref;
            key 'profile-uuid';
            config false;
            description "none";
        }
        list sink-profile {
            uses tapi-common:profile-ref;
            key 'profile-uuid';
            config false;
            description "none";
        }
        list source-profile {
            uses tapi-common:profile-ref;
            key 'profile-uuid';
            config false;
            description "none";
        }
        leaf direction {
            type tapi-common:direction;
            config false;
            description "The NEP direction.";
        }
        leaf link-port-role {
            type tapi-common:port-role;
            config false;
            description "The role of the (conceptual) port of the associated Link.";
        }
        uses tapi-common:global-class;
        uses tapi-common:admin-state-pac;
        uses tapi-common:capacity-pac;
        description "The NodeEdgePoint (NEP) is a topological entity which represents the ingress-egress edge-port functions that access the forwarding capabilities provided by the Node.
            Hence it provides an encapsulation of addressing, mapping, termination, adaptation and OAM functions of one or more transport layers (including circuit and packet forms) performed at the entry and exit points of the Node.";
    }
    grouping risk-parameter-pac {
        list risk-characteristic {
            key 'risk-characteristic-name';
            config false;
            min-elements 1;
            uses risk-characteristic;
            description "A list of risk characteristics for consideration in an analysis of shared risk. Each element of the list represents a specific risk consideration.";
        }
        description "The risk characteristics of a topological entity (e.g. the Link) come directly from the underlying physical realization. 
            The risk characteristics propagate from the physical realization to the client and from the server layer to the client layer, this propagation may be modified by protection.
            A topological entity may suffer degradation or failure as a result of a problem in a part of the underlying realization.
            The realization can be partitioned into segments which have some relevant common failure modes.
            There is a risk of failure/degradation of each segment of the underlying realization.
            Each segment is a part of a larger physical/geographical unit that behaves as one with respect to failure (i.e. a failure will have a high probability of impacting the whole unit (e.g. all cables in the same duct).
            Disruptions to that larger physical/geographical unit will impact (cause failure/errors to) all topological entities that use any part of that larger physical/geographical entity.
            Any topological entity that uses any part of that larger physical/geographical unit will suffer impact and hence each topological entity shares risk.
            The identifier of each physical/geographical unit that is involved in the realization of each segment of a topological entity can be listed in the RiskParameter_Pac of that topological entity.
            A segment has one or more risk characteristic.
            Shared risk between two topological entities compromises the integrity of any solution that use one of those topological entity as a backup for the other.
            Where two topological entities have a common risk characteristic they have an elevated probability of failing simultaneously compared to two topological entities that do not share risk characteristics.";
    }
    grouping transfer-cost-pac {
        list cost-characteristic {
            key 'cost-name';
            config false;
            min-elements 1;
            uses cost-characteristic;
            description "The list of costs where each cost relates to some aspect of the topological entity.";
        }
        description "The cost characteristics of a topological entity (e.g. a Link or a Node) not necessarily correlated to the cost of the underlying physical realization. 
            They may be quite specific to the individual topological entity e.g. opportunity cost. Relates to layer capacity.
            There may be many perspectives from which cost may be considered  for a particular topological entity and hence many specific costs and potentially cost algorithms. 
            Using an entity will incur a cost.";
    }
    grouping transfer-integrity-pac {
        leaf error-characteristic {
            type string;
            config false;
            description "Describes the degree to which the signal propagated can be errored. 
                Applies to TDM systems as the errored signal will be propagated and not to packet as errored packets will be discarded.";
        }
        leaf loss-characteristic {
            type string;
            config false;
            description "Describes the acceptable characteristic of lost packets where loss may result from discard due to errors or overflow.
                Applies to packet systems and not to TDM (as for TDM errored signals are propagated unless grossly errored and overflow/underflow turns into timing slips).";
        }
        leaf repeat-delivery-characteristic {
            type string;
            config false;
            description "Primarily applies to packet systems where a packet may be delivered more than once (in fault recovery for example). 
                It can also apply to TDM where several frames may be received twice due to switching in a system with a large differential propagation delay.";
        }
        leaf delivery-order-characteristic {
            type string;
            config false;
            description "Describes the degree to which packets will be delivered out of sequence.
                Does not apply to TDM as the TDM protocols maintain strict order.";
        }
        leaf unavailable-time-characteristic {
            type string;
            config false;
            description "Describes the duration for which there may be no valid signal propagated.";
        }
        leaf server-integrity-process-characteristic {
            type string;
            config false;
            description "Describes the effect of any server integrity enhancement process on the characteristics of the topological entity.";
        }
        description "Transfer integrity characteristic covers expected/specified/acceptable characteristic of degradation of the transfered signal.
            It includes all aspects of possible degradation of signal content as well as any damage of any form to the total topological entity and to the carried signals.
            Note that the statement is of total impact to the topological entity so any partial usage of the topological entity (e.g. a signal that does not use full capacity) will only suffer its portion of the impact.";
    }
    grouping transfer-timing-pac {
        list latency-characteristic {
            key 'traffic-property-name';
            config false;
            min-elements 1;
            uses latency-characteristic;
            description "The effect on the latency of a queuing process. This only has significant effect for packet based systems and has a complex characteristic.";
        }
        description "A topological entity (e.g. a Link or a Node) will suffer effects from the underlying physical realization related to the timing of the information passed by the topological entity.";
    }
    grouping validation-pac {
        list validation-mechanism {
            key 'validation-mechanism';
            config false;
            min-elements 1;
            uses validation-mechanism;
            description "Provides details of the specific validation mechanism(s) used to confirm the presence of an intended topological entity.";
        }
        description "Validation covers the various adjacency discovery and reachability verification protocols. Also may cover information source and degree of integrity.";
    }
    grouping network-topology-service {
        list topology {
            uses topology-ref;
            key 'topology-uuid';
            config false;
            description "The Topology instance(s) tracking the state of the allocated resources for the support of the NetworkTopologyService.";
        }
        uses tapi-common:global-class;
        description "A NetworkTopologyService represents an 'intent-like' request for topology related provisioning, for future developments.
            The NetworkTopologyService is a container for topology request details and is distinct from the Topology that realize the request.";
    }
    grouping topology-context {
        container nw-topology-service {
            config false;
            uses network-topology-service;
            description "The defined operations.";
        }
        list topology {
            key 'uuid';
            config false;
            uses topology;
            description "The included Topology instances.";
        }
        description "This object class represents the scope of control that a particular SDN controller has with respect to a particular network, specifically regarding the topology description.
            An instance of this class includes its Topology object instances.";
    }
    grouping inter-rule-group {
        list rule {
            key 'local-id';
            config false;
            min-elements 1;
            uses rule;
            description "The list of rules of the InterRuleGroup.";
        }
        list associated-node-rule-group {
            uses node-rule-group-ref;
            key 'topology-uuid node-uuid node-rule-group-uuid';
            config false;
            min-elements 2;
            description "The NodeRuleGroups that the InterRuleGroup constrains interconnection between.
                The CEPs of the NEPs of a referenced NodeRuleGroup can interconnect to the CEPs of the NEPs of another referenced NodeRuleGroup constrained by the rules of the InterRuleGroup.";
        }
        uses tapi-common:global-class;
        uses tapi-common:capacity-pac;
        uses transfer-cost-pac;
        uses transfer-timing-pac;
        uses risk-parameter-pac;
        description "Rules that apply between groups of NodeEdgePoint (NEP) instances.";
    }
    grouping node-rule-group {
        list rule {
            key 'local-id';
            config false;
            min-elements 1;
            uses rule;
            description "The list of rules of the NodeRuleGroup.";
        }
        list node-edge-point {
            uses node-edge-point-ref;
            key 'topology-uuid node-uuid node-edge-point-uuid';
            config false;
            description "NEPs and their client CEPs that the rules apply to. This reference is optional, while the reverse reference is mandatory (NEP refers to NRGs).";
        }
        list node-rule-group {
            uses node-rule-group-ref;
            key 'topology-uuid node-uuid node-rule-group-uuid';
            config false;
            description "NodeRuleGroups may be nested such that finer grained rules may be applied.
                A nested rule group should have a subset of the NEPs of the superior rule group.";
        }
        uses tapi-common:global-class;
        uses tapi-common:capacity-pac;
        uses transfer-cost-pac;
        uses transfer-timing-pac;
        uses risk-parameter-pac;
        description "Rules that apply to a group of NodeEdgePoint (NEP) instances.";
    }
    grouping rule {
        leaf-list rule-type {
            type rule-type;
            config false;
            description "The focus of the rule.";
        }
        leaf forwarding-rule {
            type forwarding-rule;
            config false;
            description "Rule that restricts the creation/deletion of a Connection between points in the NodeRuleGroup or related by the InterRuleGroup between NodeRuleGroups.";
        }
        leaf override-priority {
            type uint64;
            config false;
            description "The overridePriority allows for one rule in a rule group to override another.
                Priority n rules override priority n+1 rules.
                Rules of the same priority override as follows (n overrides n+1):
                1 - MustNot,
                2 - Must,
                3 - May,
                4 - Null.
                Within a rule the flexibility rules (signal, port role...) override as follows (n overrides n+1):
                1 - Any,
                2 - Same,
                3 - Different.
                Where there are two or more 'Same' rules, they will form an intersection where all must be met.
                ";
        }
        leaf-list cep-direction {
            type tapi-common:direction;
            config false;
            description "The list of CEP directions that the rule applies to. No entry means all CEP directions.";
        }
        list cep-port-role {
            config false;
            uses port-role-rule;
            description "Indicates the port role to which the rule applies. 
                The port role is interpreted in the context of the connection type which is identified by the connection spec, if any.
                The port role is not meaningful in the absence of a connection spec reference.
                If a NodeRuleGroup carries a port role, that role applies also to the associated InterRuleGroup where the combination of the roles in the NodeRuleGroups at the ends of the InterGroupRule define the Connection orientation.
                For example a root-and-leaf Connection may be used in a Node where a NodeRuleGroup collects one set of NEPs has the port role 'root' and another NodeRuleGroup collects another set of NEPs has the port role 'leaf' where these are joined by an InterRuleGroup.
                This combination specifies an allowed orientation of the root-and-leaf Connection.
                No port role statement means all port roles are allowed.";
        }
        list connection-spec-reference {
            config false;
            uses connection-spec-reference;
            description "Identifies the type of Connection that the rule applies to. 
                If the attribute is not present then the rule applies to all types of Connection supported by the device.";
        }
        leaf-list layer-protocol-qualifier {
            type tapi-common:layer-protocol-qualifier;
            config false;
            description "Qualifies a rule for a particular layer protocol identifying the qualifiers that the rule applies to.
                If the attribute is not present then the rule applies to all relevant qualifiers of the layer protocol of the parent entity.";
        }
        container signal-property {
            config false;
            uses signal-property-rule;
            description "The rule only applies to signals with the properties listed. 
                If the attribute is not present then the rule applies to all signals.";
        }
        leaf-list complex-rule {
            type string;
            config false;
            description "Allows for more complex rules where the basic rule system is not sufficient.";
        }
        list profile {
            uses tapi-common:profile-ref;
            key 'profile-uuid';
            config false;
            description "none";
        }
        list sink-profile {
            uses tapi-common:profile-ref;
            key 'profile-uuid';
            config false;
            description "none";
        }
        list source-profile {
            uses tapi-common:profile-ref;
            key 'profile-uuid';
            config false;
            description "none";
        }
        uses tapi-common:local-class;
        description "Single complex rule statement.
            A Node with no rule group has no restrictions and is essentially May/Any.
            A NodeRuleGroup constrains the CEP connectability in the Node.
            A Connection from a CEP/NEP must abide by all rules that relate to that CEP/NEP.
            Rules that are for a particular layerProtocolQualifier, connectionSpecReference, cepPortRole and cepDirection combination must be abided by in combination as dictated by overridePriority.
            If a particular connectionSpecReference does not have any rule statements then it is not supported and connections of that type are not possible within the rule group.
            If a particular cepPortRole of a particular connectionSpecReference does not have any rule statements then it is not supported and connections of that connectionSpecReference (type) cannot have that cepPortRole for CEPs from NEPs in that rule group.
            If a particular cepDirection for a particular connectionSpecReference does not have any rule statements then it is not supported and connections of that connectionSpecReference (type) cannot have that cepPortDirection for CEPs from NEPs in that rule group.
            Rules that are for different layerProtocolQualifiers or connectionSpecReferences are independent and provide options for Connection in the NodeRuleGroup.
            Some rules may apply to multiple connectionSpecReferences and all cepPortRoles and all cepDirections.";
    }
    grouping inter-domain-plug-id-pac {
        leaf plug-id-inter-domain-local-id {
            type string;
            description "Source Access Point Identifier (SAPI) in TxTI.
                G.709 TxTI: string[64 bytes]: The Trail Trace Identifier (TTI) information, provisioned by the managing system at the termination source, to be placed in the TTI overhead position of the source of a trail for transmission.";
        }
        leaf plug-id-inter-domain-remote-id {
            type string;
            description "Expected Source Access Point Identifier (ExSAPI).
                G.709 ExSAPI: Provisioned by the managing system, to be compared with the TTI accepted (AcTI) at the overhead position of the sink for the purpose of checking the integrity of connectivity.
                AcTI: string [64 bytes] The Trail Trace Identifier (TTI) information recovered (Accepted) from the TTI overhead position at the sink of a trail.";
        }
        description "NEP at ENNI shall include an ENNI identifier (inter domain plug id) which must be unique in both the connected managed domains, to support the automatic discovery of interdomain links between E-NNI interfaces of e.g. different network providers.
            The inter domain plug id can be based on OTN technology (OTU or ODU Trail Trace Identifier, SAPI).
            ITU-T G.709: The access point identifier shall consist of a three-character international segment and a twelve-character national segment coded according to [ITU-T  T.50].
            The international segment field provides a three-character ISO 3166 geographic/political country code (G/PCC).
            The country code shall be based on the three-character uppercase alphabetic ISO 3166 country code.
            The national segment field consists of two subfields: the ITU carrier code (ICC) followed by a unique access point code (UAPC).
            The ITU carrier code is assigned to a network operator/service provider and shall consist of 1-6 left-justified characters, alphabetic, or leading alphabetic with trailing numeric [e.g., 'USATELCORuapc'].";
    }

    /**************************
    * package type-definitions
    **************************/ 
    identity FORWARDING_RULE {
        description "none";
    }
    identity FORWARDING_RULE_MAY_FORWARD_ACROSS_GROUP {
        base FORWARDING_RULE;
        description "NEPs referenced by the NodeRuleGroup (or indirectly by the InterRuleGroup between NodeRuleGroups) may have Connections created between them unless some other rule overrides this.
            For an InterRuleGroup points in a NodeRuleGroup at one end of the InterRuleGroup may be connected to points in a NodeRuleGroup at another end of the InterRuleGroup.";
    }
    identity FORWARDING_RULE_MUST_FORWARD_ACROSS_GROUP {
        base FORWARDING_RULE;
        description "NEPs referenced by the NodeRuleGroup (or indirectly by the InterRuleGroup between NodeRuleGroups) MUST have Connections created between them unless some other rule overrides this.
            For an InterRuleGroup points in a NodeRuleGroup at one end of the InterRuleGroup MUST be connected to points in a NodeRuleGroup at another end of the InterRuleGroup.";
    }
    identity FORWARDING_RULE_CANNOT_FORWARD_ACROSS_GROUP {
        base FORWARDING_RULE;
        description "NEPs referenced by the NodeRuleGroup (or indirectly by the InterRuleGroup between NodeRuleGroups) MUST NOT have Connections created between them.
            For an InterRuleGroup points in a NodeRuleGroup at one end of the InterRuleGroup MUST NOT be connected to points in an NodeRuleGroup at another end of the InterRuleGroup.";
    }
    identity FORWARDING_RULE_NO_STATEMENT_ON_FORWARDING {
        base FORWARDING_RULE;
        description "The rule group makes no statement on forwarding.";
    }
    identity FORWARDING_RULE_INTER_CONNECTION_CONTENTION {
        base FORWARDING_RULE;
        description "Connections to NEPs in the Rule Group contend for resources based upon a constraint of some signal property.
            For example, each Connection to a NEP in the Group must use a different value of the signal property from all other Connections to NEPs in the Rule Group.
            For example, each Connection to a NEP in the Group must use a same value of the signal property as all other Connections to NEPs in the Rule Group. In this case the first Connection created in the Rule Group sets the value and the Group constraint is freed when the last Connection is deleted.";
    }
    identity TOPOLOGY_OBJECT_TYPE {
    	base tapi-common:OBJECT_TYPE;
        description "none";
    }
    identity TOPOLOGY_OBJECT_TYPE_TOPOLOGY {
        base TOPOLOGY_OBJECT_TYPE;
        description "The Topology class.";
    }
    identity TOPOLOGY_OBJECT_TYPE_NODE {
        base TOPOLOGY_OBJECT_TYPE;
        description "The Node class.";
    }
    identity TOPOLOGY_OBJECT_TYPE_LINK {
        base TOPOLOGY_OBJECT_TYPE;
        description "The Link class.";
    }
    identity TOPOLOGY_OBJECT_TYPE_NODE_EDGE_POINT {
        base TOPOLOGY_OBJECT_TYPE;
        description "The NodeEdgePoint (NEP) class.";
    }
    identity TOPOLOGY_OBJECT_TYPE_NODE_RULE_GROUP {
        base TOPOLOGY_OBJECT_TYPE;
        description "The NodeRuleGroup class.";
    }
    identity TOPOLOGY_OBJECT_TYPE_INTER_RULE_GROUP {
        base TOPOLOGY_OBJECT_TYPE;
        description "The InterRuleGroup class.";
    }
    identity TOPOLOGY_OBJECT_TYPE_RULE {
        base TOPOLOGY_OBJECT_TYPE;
        description "The Rule class.";
    }
    identity TOPOLOGY_OBJECT_TYPE_NETWORK_TOPOLOGY_SERVICE {
        base TOPOLOGY_OBJECT_TYPE;
        description "The NetworkTopologyService class.";
    }
    identity PORT_ROLE_RULE_OPTION {
        description "none";
    }
    identity PORT_ROLE_RULE_OPTION_SAME_ROLE {
        base PORT_ROLE_RULE_OPTION;
        description "The (conceptual) ports of the Connection to which the rule applies must have the same role from the list in port role.";
    }
    identity PORT_ROLE_RULE_OPTION_DIFFERENT_ROLE {
        base PORT_ROLE_RULE_OPTION;
        description "The (conceptual) ports of the Connection to which the rule applies must have different roles from the list in port role.";
    }
    identity PORT_ROLE_RULE_OPTION_ANY_ROLE {
        base PORT_ROLE_RULE_OPTION;
        description "The (conceptual) ports of the Connection to which the rule applies may take any identified role.";
    }
    identity PORT_ROLE_RULE_OPTION_NOT_ROLE {
        base PORT_ROLE_RULE_OPTION;
        description "The (conceptual) ports of the Connection to which the rule applies must not have any of the listed roles.";
    }
    identity SIGNAL_PROPERTY_VALUE_RULE {
        description "none";
    }
    identity SIGNAL_PROPERTY_VALUE_RULE_SAME_VALUE {
        base SIGNAL_PROPERTY_VALUE_RULE;
        description "The signal property of the CEP to which the rule applies must have the same value from the identied list.";
    }
    identity SIGNAL_PROPERTY_VALUE_RULE_ANY_VALUE {
        base SIGNAL_PROPERTY_VALUE_RULE;
        description "The signal property of the CEP to which the rule applies may take any identified value.";
    }
    identity SIGNAL_PROPERTY_VALUE_RULE_DIFFERENT_VALUE {
        base SIGNAL_PROPERTY_VALUE_RULE;
        description "The signal property of the CEP to which the rule applies each must have different values from the identified list.";
    }
    identity SIGNAL_PROPERTY_VALUE_RULE_NOT_VALUE {
        base SIGNAL_PROPERTY_VALUE_RULE;
        description "The signal property of the CEP to which the rule applies must not have any of the identified values.";
    }
    grouping cost-characteristic {
        leaf cost-name {
            type string;
            description "The cost characteristic will be related to some aspect of the topological entity (e.g. $ cost, routing weight). This aspect will be conveyed by the costName.";
        }
        leaf cost-value {
            type string;
            description "The specific cost.";
        }
        leaf cost-algorithm {
            type string;
            description "The cost may vary based upon some properties of the topological entity. The rules for the variation are conveyed by the costAlgorithm.";
        }
        description "The cost characteristic related to some aspect of a topological entity.";
    }
    grouping latency-characteristic {
        leaf traffic-property-name {
            type string;
            description "The identifier of the specific traffic property to which the queuing latency applies.";
        }
        leaf fixed-latency-characteristic {
            type string;
            config false;
            description "A topological entity suffers delay caused by the realization of the servers (e.g. distance related; FEC encoding etc.) along with some client specific processing.
                This is the total average latency effect of the topological entity.";
        }
        leaf queuing-latency-characteristic {
            type string;
            description "The specific queuing latency for the traffic property.";
        }
        leaf jitter-characteristic {
            type string;
            config false;
            description "High frequency deviation from true periodicity of a signal and therefore a small high rate of change of transfer latency.
                Applies to TDM systems (and not packet).";
        }
        leaf wander-characteristic {
            type string;
            config false;
            description "Low frequency deviation from true periodicity of a signal and therefore a small low rate of change of transfer latency.
                Applies to TDM systems (and not packet).";
        }
        description "Provides information on latency characteristic for a particular stated trafficProperty.";
    }
    grouping risk-characteristic {
        leaf risk-characteristic-name {
            type string;
            description "The name of the risk characteristic. The characteristic may be related to a specific degree of closeness. 
                For example a particular characteristic may apply to failures that are localized (e.g. to one side of a road) where as another characteristic may relate to failures that have a broader impact (e.g. both sides of a road that crosses a bridge).
                Depending upon the importance of the traffic being routed different risk characteristics will be evaluated.";
        }
        leaf-list risk-identifier-list {
            type string;
            min-elements 1;
            description "A list of the identifiers of each physical/geographic unit (with the specific risk characteristic) that is related to a segment of the topological entity.";
        }
        description "The information for a particular risk characteristic where there is a list of risk identifiers related to that characteristic.";
    }
    grouping validation-mechanism {
        leaf validation-mechanism {
            type string;
            description "Name of mechanism used to validate adjacency.";
        }
        leaf layer-protocol-adjacency-validated {
            type string;
            description "State of validation.";
        }
        leaf validation-robustness {
            type string;
            description "Quality of validation (i.e. how likely is the stated validation to be invalid).";
        }
        description "Identifies the validation mechanism and describes the characteristics of that mechanism.";
    }
    typedef forwarding-rule {
        type identityref {
            base FORWARDING_RULE;
        }
        description "Rule that restricts the creation/deletion of a Connection between points referenced by rule groups.";
    }
    typedef rule-type {
        type enumeration {
            enum FORWARDING {
                description "The rule applies to the creation of Connections.";
            }
            enum CAPACITY {
                description "The rule applies to capacity limitations.";
            }
            enum COST {
                description "The rule applies to the cost of the creation of Connections.";
            }
            enum TIMING {
                description "The rule applies to timing constraints across the group.";
            }
            enum RISK {
                description "The rule applies to risk considerations across the group so as to express shared risk.";
            }
            enum GROUPING {
                description "The rule is simply for grouping related to other rules.";
            }
            enum IMPAIRMENT {
                description "none";
            }
        }
        description "The focus of the rule.";
    }
    typedef restoration-policy {
        type enumeration {
            enum PER_DOMAIN_RESTORATION {
                description "Restoration is expected to be performed independently within each (restoration) domain scope.
                    This implies that the server is responsible of activating the required control mechanisms to guarantee the restoration of the service autonomously.";
            }
            enum END_TO_END_RESTORATION {
                description "Restoration is expected to be performed on end to end basis across all domain(s).";
            }
            enum NA {
                description "Not Applicable.";
            }
        }
        description "The restoration policy.";
    }
    typedef protection-type {
        type enumeration {
            enum NO_PROTECTION {
                description "none";
            }
            enum ONE_PLUS_ONE_PROTECTION {
                description "Protection scheme where the switches are not required to be coordinated (typically the signal is always bridged).";
            }
            enum ONE_PLUS_ONE_PROTECTION_WITH_DYNAMIC_RESTORATION {
                description "Protection scheme where the switches are not required to be coordinated (typically the signal is always bridged).
                    In addition is implemented a second level of resilience, through dynamic restoration of the first connection affected by a failure.";
            }
            enum PERMANENT_ONE_PLUS_ONE_PROTECTION {
                description "Extends the ONE_PLUS_ONE_PROTECTION_WITH_DYNAMIC_RESTORATION allowing an indeterminate number of failures to affect either of the 1+1 routes and the respective subsequent dynamic restorations.";
            }
            enum ONE_FOR_ONE_PROTECTION {
                description "Protection scheme where the switches are coordinated (e.g. by signalling).";
            }
            enum DYNAMIC_RESTORATION {
                description "Restoration scheme where the protection route is computed and implemented only when the current (and only) route is impaired (e.g. by a failure or maintenance command).";
            }
            enum PRE_COMPUTED_RESTORATION {
                description "Restoration scheme where the protection route is pre-computed.
                    When the current (and only) route is impaired (e.g. by a failure or maintenance command) the pre-computed route is implemented.";
            }
            enum ONE_PLUS_ONE_PROTECTION_WITH_PRE_COMPUTED_RESTORATION {
                description "Protection scheme where the switches are not required to be coordinated (typically the signal is always bridged).
                    In addition a further protection route is pre-computed.
                    When either the current or protection route is impaired (e.g. by a failure or maintenance command), the pre-computed route is implemented to restore resiliency level.";
            }
            enum ONE_FOR_N_PROTECTION {
                description "N routes share one protection route. Switches need coordination (e.g. by signalling).";
            }
            enum M_FOR_N_PROTECTION {
                description "N routes share M protection routes. Switches need coordination (e.g. by signalling).";
            }
            enum ONE_FOR_ONE_BY_N {
                description "N parallel one-for-one schemes.";
            }
        }
        description "The types of protection and restoration.";
    }
    typedef topology-object-type {
        type identityref {
            base TOPOLOGY_OBJECT_TYPE;
        }
        description "The list of TAPI Topology Global Object Class types on which Notification signals can be raised.";
    }
    grouping port-role-rule {
        leaf-list port-role {
            type port-role;
            config false;
            description "The role(s) of the port(s) considered in the rule.";
        }
        leaf-list port-role-rule {
            type port-role-rule-option;
            config false;
            description "Where the rule references more than one (conceptual) port role or where there are rule intersections either as a result of overlay of rules or InterRuleGroup usage indicates role matching criteria for a Connection following the rules.
                For example if two port roles, 'a' and 'b', are listed and the port role rule is 'different', this means that a Connection connecting CEPs in that group must have port roles that are different for each CEP in that group.
                In the example if a Connection can have n ports of role 'a' and m ports of role 'b' then a maximum of two ports can be drawn from the NEPs of the group and where there are two, one must be role 'a' and one must be role 'b'.";
        }
        description "Constrains which (conceptual) port roles the rule applies to.";
    }
    typedef port-role {
        type string;
        description "The role of a (conceptual) port in the context of the Connection spec referenced in the rule.";
    }
    typedef port-role-rule-option {
        type identityref {
            base PORT_ROLE_RULE_OPTION;
        }
        description "Indicates how to interpret the port role list.";
    }
    grouping connection-spec-reference {
        leaf connection-spec-name {
            type string;
            config false;
            description "The name of the Connection type spec.
                This can be used as a reference to a paper document where full formal machine interpretable specs are not supported.";
        }
        leaf connection-spec {
            type tapi-common:uuid;
            description "The reference to the formal Connection type spec.";
        }
        description "The definition of the type of Connection.
            This definition will explain the flows in the Connection and how they relate to the roles of (conceptual) ports.";
    }
    typedef signal-property-value-rule {
        type identityref {
            base SIGNAL_PROPERTY_VALUE_RULE;
        }
        description "Indicates how to interpret the signal property value rule.";
    }
    grouping signal-property-rule {
        leaf signal-property-name {
            type string;
            config false;
            description "The name of the signal property to which the rule applies.";
        }
        leaf signal-property-value-rule {
            type signal-property-value-rule;
            config false;
            description "Indicates how the signal properties should be accounted for.";
        }
        leaf-list applicable-signal-value {
            type string;
            config false;
            description "Specific values of the signal property to which the rule applies.";
        }
        leaf number-of-signal-values {
            type uint64;
            config false;
            description "The number of instances of this specific property that can be supported by the group.";
        }
        description "Rule related to an identified signal property.";
    }
    grouping resilience-type {
        leaf restoration-policy {
            type restoration-policy;
            description "The restoration policy.";
        }
        leaf protection-type {
            type protection-type;
            description "The protection type.";
        }
        description "The type of resiliency (protection/restoration).";
    }

    /**************************
    * package interfaces
    **************************/ 
    rpc get-topology-details {
        description "none";
        input {
            leaf topology-id {
                type tapi-common:uuid;
                description "UUID of the Topology instance.
                    UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable.
                    An UUID carries no semantics with respect to the purpose or state of the entity.
                    UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
                    Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12} 
                    Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6";
            }
        }
        output {
            container topology {
                uses topology;
                description "The requested Topology instance.";
            }
        }
    }
    rpc get-node-details {
        description "none";
        input {
            leaf topology-id {
                type tapi-common:uuid;
                description "UUID of the parent Topology instance.
                    UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable.
                    An UUID carries no semantics with respect to the purpose or state of the entity.
                    UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
                    Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12} 
                    Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6";
            }
            leaf node-id {
                type tapi-common:uuid;
                description "UUID of the Node instance.
                    UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable.
                    An UUID carries no semantics with respect to the purpose or state of the entity.
                    UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
                    Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12} 
                    Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6";
            }
        }
        output {
            container node {
                uses node;
                description "The requested Node instance.";
            }
        }
    }
    rpc get-node-edge-point-details {
        description "none";
        input {
            leaf topology-id {
                type tapi-common:uuid;
                description "UUID of the parent Node's Topology instance.
                    UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable.
                    An UUID carries no semantics with respect to the purpose or state of the entity.
                    UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
                    Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12} 
                    Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6";
            }
            leaf node-id {
                type tapi-common:uuid;
                description "UUID of the parent Node instance.
                    UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable.
                    An UUID carries no semantics with respect to the purpose or state of the entity.
                    UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
                    Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12} 
                    Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6";
            }
            leaf node-edge-point-id {
                type tapi-common:uuid;
                description "UUID of the NodeEdgePoint (NEP) instance.
                    UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable.
                    An UUID carries no semantics with respect to the purpose or state of the entity.
                    UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
                    Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12} 
                    Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6";
            }
        }
        output {
            container node-edge-point {
                uses node-edge-point;
                description "The requested NodeEdgePoint (NEP) instance.";
            }
        }
    }
    rpc get-link-details {
        description "none";
        input {
            leaf topology-id {
                type tapi-common:uuid;
                description "UUID of the parent Topology instance.
                    UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable.
                    An UUID carries no semantics with respect to the purpose or state of the entity.
                    UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
                    Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12} 
                    Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6";
            }
            leaf link-id {
                type tapi-common:uuid;
                description "UUID of the Link instance.
                    UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable.
                    An UUID carries no semantics with respect to the purpose or state of the entity.
                    UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
                    Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12} 
                    Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6";
            }
        }
        output {
            container link {
                uses link;
                description "The requested Link instance.";
            }
        }
    }
    rpc get-topology-list {
        description "none";
        output {
            list topology {
                key 'uuid';
                uses topology;
                description "The requested list of Topology instances.";
            }
        }
    }

}
